/-
  Papers/P3_2CatFramework/Phase2_PositiveTruthAlgebra.lean

  Truth-family algebra for positive uniformization (Part II).
  - A truth-family is generated by a boolean predicate over foundations and Σ₀.
  - Positive uniformization reduces to "the predicate is uniformly true on W".
  - Product (conjunction) law follows immediately.
-/
import Papers.P3_2CatFramework.Phase2_Positive

namespace Papers.P3.Phase2Positive

open Papers.P3.Phase2
open Papers.P3.Phase2API

/-! ## Truth families -/

/-- The witness family whose fibers are `Truth (B F X)`. -/
def TruthFamily (B : Phase2.Foundation → Sigma0 → Bool) : WitnessFamily where
  C := fun F X => Truth (B F X)

@[simp] lemma TruthFamily_C
  (B : Phase2.Foundation → Sigma0 → Bool)
  (F : Phase2.Foundation) (X : Sigma0) :
  (TruthFamily B).C F X = Truth (B F X) := rfl

/-! ## Characterization of positive uniformization for truth families -/

/-- Positive uniformization of a truth-family is exactly:
    "the boolean is uniformly `true` on W at every pinned object". -/
lemma posUL_truth_iff
  {W : Phase2.Foundation → Prop}
  {B : Phase2.Foundation → Sigma0 → Bool} :
  PosUniformizableOn W (TruthFamily B)
    ↔ (∀ {F} (hF : W F) (X : Sigma0), B F X = true) := by
  constructor
  · -- → : extract `true` everywhere from the non-emptiness component
    intro h; rcases h with ⟨_, ne⟩
    intro F hF X
    exact (nonempty_Truth_iff (b := B F X)).1 (ne hF X)
  · -- ← : build the positive uniformization using PUnit as a pivot
    intro hAll
    -- Equivalence to PUnit at each (F,X) on W
    let toUnit (F : Phase2.Foundation) (hF : W F) (X : Sigma0) :
        (TruthFamily B).C F X ≃ PUnit := by
      have hb : B F X = true := hAll hF X
      simp only [TruthFamily_C, hb, Truth_true]
      exact Equiv.refl PUnit
    -- Build the uniformization via the PUnit pivot
    refine ⟨
      { η := by
          intro F F' _ hF hF' X
          exact (toUnit F hF X).trans ((toUnit F' hF' X).symm)
        η_id := by
          intro F hF X
          -- Everything reduces to `Equiv.refl PUnit`
          simp [toUnit, TruthFamily_C, Truth_true, hAll hF X]
        η_comp := by
          intro F G H φ ψ hF hG hH X
          -- Again, everything is `Equiv.refl PUnit` after rewriting
          simp [toUnit, TruthFamily_C, Truth_true,
                hAll hF X, hAll hG X, hAll hH X]
          rfl },
      ?_⟩
    -- Non-emptiness of fibers: `Truth true` is inhabited
    intro F hF X
    have hb : B F X = true := hAll hF X
    simpa [TruthFamily_C, hb, Truth_true] using
      (nonempty_Truth_true : Nonempty (Truth true))

/-! ## Boolean helper -/

@[simp] lemma and_eq_true {b c : Bool} :
  (b && c = true) ↔ (b = true ∧ c = true) := by
  cases b <;> cases c <;> decide

/-! ## Product (Conjunction) law for truth families -/

/-- Positive uniformization distributes over boolean conjunction, on the same `W`. -/
theorem pos_UL_and
    (W : Phase2.Foundation → Prop)
    (B C : Phase2.Foundation → Sigma0 → Bool) :
  PosUniformizableOn W (TruthFamily (fun F X => B F X && C F X))
    ↔ (PosUniformizableOn W (TruthFamily B) ∧ PosUniformizableOn W (TruthFamily C)) := by
  simp only [posUL_truth_iff]
  constructor
  · intro h
    constructor
    · intro F hF X
      have := h hF X
      cases hB : B F X <;> cases hC : C F X <;> simp [hB, hC] at this ⊢
    · intro F hF X
      have := h hF X
      cases hB : B F X <;> cases hC : C F X <;> simp [hB, hC] at this ⊢
  · rintro ⟨hB, hC⟩
    intro F hF X
    have b_true := hB hF X
    have c_true := hC hF X
    simp [b_true, c_true]

/-! ## More truth-family algebra -/

@[simp] lemma or_eq_true {b c : Bool} :
  (b || c = true) ↔ (b = true ∨ c = true) := by
  cases b <;> cases c <;> decide

/-- **Disjunction (pointwise)**:
`PosUniformizableOn W (TruthFamily (B || C))` iff
for every `F∈W` and `X`, either `B F X` or `C F X` is `true`. -/
theorem pos_UL_or_pointwise
    (W : Phase2.Foundation → Prop)
    (B C : Phase2.Foundation → Sigma0 → Bool) :
  PosUniformizableOn W (TruthFamily (fun F X => B F X || C F X))
    ↔ (∀ {F} (hF : W F) (X : Sigma0), B F X = true ∨ C F X = true) := by
  simp only [posUL_truth_iff]
  constructor
  · intro h F hF X
    have := h hF X
    cases hB : B F X <;> cases hC : C F X <;> simp [hB, hC] at this ⊢
  · intro h F hF X
    cases h hF X with
    | inl hB => simp [hB]
    | inr hC => simp [hC]

/-- **Monotonicity** for truth families:
if `B ⇒ C` pointwise (on booleans), then positivity of `B` implies positivity of `C`. -/
theorem pos_UL_mono_truth
    (W : Phase2.Foundation → Prop)
    {B C : Phase2.Foundation → Sigma0 → Bool}
    (hBC : ∀ F X, B F X = true → C F X = true) :
  PosUniformizableOn W (TruthFamily B) →
  PosUniformizableOn W (TruthFamily C) := by
  intro hB
  simp only [posUL_truth_iff] at hB ⊢
  intro F hF X
  exact hBC F X (hB hF X)

/-- **Bridge** to non-truth families:
if `WF` is already uniformizable on `W`, and its fibers are pointwise
equivalent (on `W`) to a truth family `Truth B`, then positivity of `WF`
is equivalent to the truth condition for `B`. -/
theorem posUL_equiv_truth_iff
  {W : Phase2.Foundation → Prop}
  {WF : WitnessFamily} {B : Phase2.Foundation → Sigma0 → Bool}
  (U : UniformizableOn W WF)
  (e : ∀ {F} (hF : W F) (X : Sigma0), (WF.C F X) ≃ Truth (B F X)) :
  PosUniformizableOn W WF
    ↔ (∀ {F} (hF : W F) (X : Sigma0), B F X = true) := by
  constructor
  · intro h
    rcases h with ⟨_, ne⟩
    intro F hF X
    obtain ⟨x⟩ := ne hF X
    have : Nonempty (Truth (B F X)) := ⟨(e hF X) x⟩
    exact (nonempty_Truth_iff (b := B F X)).1 this
  · intro hB
    refine ⟨U, ?_⟩
    intro F hF X
    have hb : B F X = true := hB hF X
    -- build a truth witness and transport it back along `e`
    have : Nonempty (Truth (B F X)) := by
      simpa [hb, Truth_true] using
        (nonempty_Truth_true : Nonempty (Truth true))
    obtain ⟨t⟩ := this
    exact ⟨(e hF X).symm t⟩

end Papers.P3.Phase2Positive