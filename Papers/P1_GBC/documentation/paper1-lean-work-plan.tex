\documentclass[11pt]{article}

% -------------------------------------------------
% Basic packages
% -------------------------------------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[american]{babel}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{xcolor}
\usepackage{enumitem}
\setlist[enumerate,1]{label=\textnormal{(\alph*)}}
\setlist[itemize]{leftmargin=1.25em}
\usepackage{booktabs}
\usepackage{array}
\usepackage{amssymb,amsmath,amsthm,amsopn}  % Added amsopn for \operatorname
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, urlcolor=blue}
\usepackage{listings}
\usepackage{mdframed}  % Added for mdframed environment

% -------------------------------------------------
% Math operators
% -------------------------------------------------
\DeclareMathOperator{\range}{range}
\newcommand{\toL}{\to_L}  % Define notation for continuous linear maps

% -------------------------------------------------
% Lean listings (minimal)
% -------------------------------------------------
\lstdefinelanguage{Lean}{
  morekeywords={structure,inductive,namespace,variable,variables,section,end,def,lemma, theorem,
  by, intro, intros, apply, exact, refine, have, show, fun, match, with, if, then, else,
  Type, Prop, Sort, open, import, classical, noncomputable, example, where, attribute, local,
  instance, deriving, protected, private, macro, simp, rw},
  sensitive=true,
  morecomment=[l]{--},
  morecomment=[s]{/-}{-/},
  morestring=[b]"
}
\lstset{
  language=Lean,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue!70!black},
  commentstyle=\color{green!50!black},
  stringstyle=\color{purple!70!black},
  showstringspaces=false,
  breaklines=true,
  frame=single,
  rulecolor=\color{black!20}
}

% -------------------------------------------------
% Title
% -------------------------------------------------
\title{\textbf{Lean Work Plan (Minimal):\\
Rank-One Toggle Kernel \& Small Mathlib Extensions}\\
\large A companion plan aligned with the WLPO~\(\leftrightarrow\)~Bidual Gap formalization}
\author{Paul Chun--Kit Lee}
\date{\today}

% -------------------------------------------------
% Document
% -------------------------------------------------
\begin{document}
\maketitle

\begin{abstract}
This work plan specifies the \emph{minimal} Lean 4 formalization we will implement and, where appropriate, upstream to \texttt{mathlib4}, in support of our Paper~2 results (the equivalence WLPO~\(\leftrightarrow\) bidual gap). The focus is a self-contained, reusable \emph{rank-one toggle} kernel on a Hilbert space, together with concise spectral/Fredholm lemmas and a Sherman--Morrison formula for projections. 

\textbf{Out of scope} (by design): the meta-level ``Gödel bridge'', any Prop\(\to\)Type elimination encodings, Banach limits, and the bicategory-of-foundations layer. The deliverables here are library-quality, axiom-clean components intended for didactic use and for Paper~3's higher-level narrative.
\end{abstract}

\tableofcontents

% =========================================================
\section{Scope and Non-Goals}\label{sec:scope}
% =========================================================

\subsection*{In scope (to implement in Lean)}
\begin{itemize}
  \item A small API for orthogonal projections onto lines in a (real or complex) Hilbert space and the \emph{rank-one toggle} operator \(G(c) := \mathrm{id} - c\cdot P\) with \(c\in\{\texttt{false},\texttt{true}\}\).
  \item Block-decomposition lemmas: explicit \(\ker\) and \(\range\) of \(G(c)\); equivalences
  \[
    \mathrm{Injective}(G(c)) \;\Leftrightarrow\; \mathrm{Surjective}(G(c)) \;\Leftrightarrow\; (c=\texttt{false}).
  \]
  \item Spectral computation for \(G(c)\): \(\sigma(G(\texttt{false}))=\{1\}\) and \(\sigma(G(\texttt{true}))=\{0,1\}\); essential spectrum \(\{1\}\) in both cases.
  \item Sherman--Morrison (projection case): \((I+\alpha P)^{-1}=I-\tfrac{\alpha}{1+\alpha}\,P\), as \texttt{ContinuousLinearMap} lemma over \(\mathbb{K}\in\{\mathbb{R},\mathbb{C}\}\), with domain assumptions.
  \item A tiny Fredholm lemma: \(I - cP\) is Fredholm of index \(0\) with one-dimensional kernel/cokernel when \(c=\texttt{true}\).
  \item Examples/tests and documentation comments; a small tutorial file showing usage.
\end{itemize}

\subsection*{Out of scope (non-goals)}
\begin{itemize}
  \item \emph{No} formalization of the meta-level Gödel bridge (Prop/Type barrier).
  \item \emph{No} Banach limits and \(\ell^\infty/c_0\) bidual surjectivity examples here (covered conceptually in Paper~2; any use of noncomputable choice is excluded from this minimal plan).
  \item \emph{No} bicategorical \(\mathbf{Found}\) layer (reserved for Paper~3 pre-Lean).
\end{itemize}

% =========================================================
\section{Toolchain, Repository Layout, and Style}\label{sec:tooling}
% =========================================================

\paragraph{Toolchain.}
Lean 4 (current stable), \texttt{mathlib4} (current master at integration time), \texttt{lake} build. Continuous integration: GitHub Actions using the \texttt{lean-action} template.

\paragraph{Repository layout (proposed).}
\begin{verbatim}
Papers/
  RankOneToggle/
    Projection.lean
    Toggle.lean
    Spectrum.lean
    ShermanMorrison.lean
    Fredholm.lean
    Tutorial.lean
\end{verbatim}

\paragraph{Naming \& style.}
Follow mathlib conventions: \texttt{snake\_case} for identifiers, lemma names that read as English, localized \texttt{simp} attributes, docstrings with \verb|/-! ... -/| explaining statements and references.

% =========================================================
\section{Deliverables and Acceptance Criteria}\label{sec:deliverables}
% =========================================================

\begin{mdframed}
\textbf{AC-0 (Build \& Lint)}: \texttt{lake build} succeeds; no \texttt{sorry}; no linter failures; all \texttt{example} tests compile.

\textbf{AC-1 (Projection API)}:
\begin{itemize}
  \item \texttt{orthogonalProjection\_line} returning \(P:\,H\toL[\mathbb{K}]H\) onto \(\mathrm{span}\{u\}\) for a unit vector \(u\).
  \item Proofs: \(P^2=P\), \(P^\ast=P\), \(\|P\|=1\) (if \(u\neq 0\)), and \(P u = u\).
\end{itemize}

\textbf{AC-2 (Toggle \& block shape)}:
\begin{itemize}
  \item \texttt{def G (c : Bool) : H →L[K] H := id - (cond c 1 0) • P}.
  \item Lemmas: kernel/range as expected; \texttt{injective\_iff} and \texttt{surjective\_iff} reduce to \(c=\texttt{false}\).
\end{itemize}

\textbf{AC-3 (Spectrum \& essential spectrum)}:
\begin{itemize}
  \item \(\sigma(G(\texttt{false}))=\{1\}\), \(\sigma(G(\texttt{true}))=\{0,1\}\).
  \item \(\sigma_{\mathrm{ess}}(G(c))=\{1\}\) (via rank-one perturbation of the identity).
\end{itemize}

\textbf{AC-4 (Sherman--Morrison for projections)}:
\begin{itemize}
  \item \texttt{lemma inverse\_id\_add\_smul\_proj} with side conditions \(1+\alpha\neq 0\).
  \item Derived resolvent formula for \((\lambda I - G(c))^{-1}\) when \(\lambda\notin\{0,1\}\).
\end{itemize}

\textbf{AC-5 (Fredholm index)}:
\begin{itemize}
  \item \texttt{isFredholm\_G} and \texttt{fredholmIndex\_G = 0}; \(\dim \ker=\dim \operatorname{coker}=1\) when \(c=\texttt{true}\).
\end{itemize}

\textbf{AC-6 (Tutorial)}:
\begin{itemize}
  \item \texttt{Tutorial.lean}: short, didactic examples showing how to instantiate \(u\), form \(P\), compute spectra, and use the resolvent.
\end{itemize}
\end{mdframed}

% =========================================================
\section{Module Specifications (with signatures)}\label{sec:modules}
% =========================================================

\subsection*{Projection.lean}
\begin{lstlisting}
namespace RankOneToggle

open ComplexConjugate

variable {K : Type*} [IsROrC K]
variable (H : Type*) [NormedAddCommGroup H] [InnerProductSpace K H]
variable (u : H) (hu : ||u|| = 1)

/-- Orthogonal projection onto the line spanned by `u` (unit vector). -/
def projLine : H →L[K] H :=
  let coeff : H →L[K] K := ⟪u, ·⟫
  -- `proj x = (⟪u, x⟫) • u`
  { toLinearMap := { toFun := fun x => (coeff x) • u, .. },
    cont := by
      -- bound by ||x|| using ||u||=1
      sorry }

lemma projLine_idem : (projLine H u hu).comp (projLine H u hu) = projLine H u hu := by
  -- P^2 = P
  sorry

lemma projLine_selfAdjoint : IsSelfAdjoint (projLine H u hu).toContinuousLinearMap := by
  -- P* = P
  sorry

lemma norm_projLine : ||projLine H u hu|| = 1 := by
  -- operator norm is 1 for nonzero unit vector
  sorry

lemma projLine_apply_self : (projLine H u hu) u = u := by
  -- P u = u
  sorry

end RankOneToggle
\end{lstlisting}

\subsection*{Toggle.lean}
\begin{lstlisting}
namespace RankOneToggle

variable {K H u hu} [IsROrC K] [NormedAddCommGroup H] [InnerProductSpace K H]

/-- Rank-one toggle operator G(c) := id - (if c then 1 else 0) • P. -/
def G (c : Bool) : H →L[K] H :=
  ContinuousLinearMap.id K H - (if c then (1 : K) else 0) • projLine (H:=H) u hu

lemma ker_G_true :
  LinearMap.ker (G (K:=K) (H:=H) (u:=u) (hu:=hu) true).toLinearMap
    = Submodule.span K {u} := by
  sorry

lemma range_G_true :
  LinearMap.range (G (K:=K) (H:=H) (u:=u) (hu:=hu) true).toLinearMap
    = (Submodule.span K {u})^⊥ := by
  sorry

lemma injective_iff (c : Bool) :
  Function.Injective (G (K:=K) (H:=H) (u:=u) (hu:=hu) c)
    ↔ c = false := by
  -- block-decomposition
  sorry

lemma surjective_iff (c : Bool) :
  Function.Surjective (G (K:=K) (H:=H) (u:=u) (hu:=hu) c)
    ↔ c = false := by
  -- same block argument
  sorry

end RankOneToggle
\end{lstlisting}

\subsection*{ShermanMorrison.lean}
\begin{lstlisting}
namespace RankOneToggle

open IsROrC

variable {K H} [IsROrC K] [NormedAddCommGroup H] [InnerProductSpace K H]

/-- Sherman–Morrison for an idempotent projection `P`: (I + α P)⁻¹ = I - α/(1+α) P.
    Side condition: (1 + α) ≠ 0. -/
lemma inverse_id_add_smul_proj
  (P : H →L[K] H) (hP : P.comp P = P) (α : K) (hα : 1 + α ≠ 0) :
  IsLeftInverse
    (ContinuousLinearMap.id K H - (α/(1+α)) • P)
    (ContinuousLinearMap.id K H + α • P) ∧
  IsRightInverse
    (ContinuousLinearMap.id K H - (α/(1+α)) • P)
    (ContinuousLinearMap.id K H + α • P) := by
  -- straightforward algebra using P^2 = P
  sorry

/-- Resolvent of `G(c)` away from {0,1}. -/
lemma resolvent_G
  (u : H) (hu : ||u|| = 1) (c : Bool) (λ : K) (hλ0 : λ ≠ 0) (hλ1 : λ ≠ 1) :
  ∃ R : H →L[K] H,
    ((λ • (ContinuousLinearMap.id K H)) - G (K:=K) (H:=H) (u:=u) (hu:=hu) c) ∘L R
    = ContinuousLinearMap.id K H := by
  -- use inverse_id_add_smul_proj with appropriate α
  sorry

end RankOneToggle
\end{lstlisting}

\subsection*{Spectrum.lean \& Fredholm.lean}
\begin{lstlisting}
namespace RankOneToggle

open scoped ComplexOrder
open Topology

variable {K H u hu} [IsROrC K] [NormedAddCommGroup H] [InnerProductSpace K H]

/-- Spectrum of the toggle. -/
lemma spectrum_G_false :
  spectrum K (G (K:=K) (H:=H) (u:=u) (hu:=hu) false) = {1} := by
  -- eigenvalue 1 on full space; block decomposition
  sorry

lemma spectrum_G_true :
  spectrum K (G (K:=K) (H:=H) (u:=u) (hu:=hu) true) = {0,1} := by
  -- 0 on span{u}, 1 elsewhere
  sorry

lemma essentialSpectrum_G (c : Bool) :
  (spectrum K (G (K:=K) (H:=H) (u:=u) (hu:=hu) c)).ess = {1} := by
  -- rank-one perturbation of id
  sorry

/-- Fredholm facts. -/
lemma fredholm_G (c : Bool) : IsFredholm (G (K:=K) (H:=H) (u:=u) (hu:=hu) c) := by
  -- finite-rank perturbation of id
  sorry

lemma fredholmIndex_G (c : Bool) :
  fredholmIndex (G (K:=K) (H:=H) (u:=u) (hu:=hu) c) = 0 := by
  sorry

end RankOneToggle
\end{lstlisting}

% =========================================================
\section{Upstream Plan to \texttt{mathlib4}}\label{sec:upstream}
% =========================================================

\paragraph{Candidate lemmas to upstream (if not present).}
\begin{itemize}
  \item \texttt{inverse\_id\_add\_smul\_proj}: Sherman--Morrison for idempotent projections at the level of \texttt{ContinuousLinearMap}.
  \item A small convenience API around \texttt{orthogonalProjection} specialized to one-dimensional subspaces generated by a unit vector.
  \item Spectral facts for block-diagonal (rank-one) perturbations of \(\mathrm{id}\), if a direct lemma is welcomed.
\end{itemize}

\paragraph{Strategy.}
Keep PRs small and self-contained:
(1) PR~A: projection-on-a-line helpers; (2) PR~B: Sherman--Morrison for projections; (3) PR~C: toggle lemmas (kernel/range, injectivity/surjectivity); (4) PR~D: spectrum/essential spectrum corollaries.

% =========================================================
\section{Proof Notes \& Dependencies}\label{sec:notes}
% =========================================================

\begin{itemize}
  \item \textbf{Block decomposition:} With \(H=\langle u\rangle\oplus \langle u\rangle^\perp\), the matrix of \(G(\texttt{false})\) is \(\begin{psmallmatrix}1&0\\0&I\end{psmallmatrix}\); of \(G(\texttt{true})\) is \(\begin{psmallmatrix}0&0\\0&I\end{psmallmatrix}\). Kernels/ranges and spectra follow immediately.
  \item \textbf{Sherman--Morrison (projection case):}
  For \(P^2=P\), \((I+\alpha P)(I-\frac{\alpha}{1+\alpha}P)=I\) provided \(1+\alpha\neq 0\).
  \item \textbf{Essential spectrum:} Rank-one (hence compact) perturbations preserve essential spectrum; use existing mathlib facts for compact perturbations of the identity.
  \item \textbf{Fredholm:} \(I-K\) with finite-rank \(K\) is Fredholm with index \(0\). For \(c=\texttt{true}\) the kernel and cokernel are one-dimensional.
\end{itemize}

% =========================================================
\section{Risks \& Mitigations}\label{sec:risks}
% =========================================================

\begin{itemize}
  \item \textbf{Prop/Type barrier:} We do \emph{not} attempt to encode any meta-level choice of a Boolean from a \(\Sigma^0_1\) predicate; all results are parameterized by a \emph{given} \texttt{Bool}.
  \item \textbf{Field generality:} Implement over \(\mathbb{K}\in\{\mathbb{R},\mathbb{C}\}\) via \texttt{IsROrC}. If an instance gap arises, specialize to \(\mathbb{C}\) first.
  \item \textbf{Existing mathlib coverage:} If an intended lemma already exists, refactor our code to use it; otherwise propose a focused PR with documentation.
\end{itemize}

% =========================================================
\section{Checklists}\label{sec:checklists}
% =========================================================

\subsection*{Developer checklist (per module)}
\begin{itemize}
  \item \texttt{\#align} comments for important lemmas to ease searchability.
  \item \texttt{simp} and \texttt{norm\_cast} lemmas localized and tested.
  \item \texttt{example} blocks demonstrating each API point compile quickly.
  \item No \texttt{noncomputable} unless forced by existing APIs (none expected here).
\end{itemize}

\subsection*{Documentation checklist}
\begin{itemize}
  \item Docstring on each definition/lemma; brief mathematical proof hints.
  \item A didactic \texttt{Tutorial.lean} with minimal imports.
\end{itemize}

% =========================================================
\section*{Attribution and Acknowledgment}
We prepared this plan with standard software-engineering practices for Lean developments. High-level brainstorming and editorial feedback benefited from LLM assistance (Google/DeepMind \emph{Gemini~2.5~Deep~Think}, OpenAI \emph{GPT-5~Pro}, Anthropic \emph{Claude~Code}); all Lean code to be committed will be authored, reviewed, and owned by the project maintainers.

% -------------------------------------------------
\end{document}