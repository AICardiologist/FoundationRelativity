-- Papers/P5_GeneralRelativity/GR/Riemann.lean
import Papers.P5_GeneralRelativity.GR.Schwarzschild

namespace Papers.P5_GeneralRelativity
open Papers.P5_GeneralRelativity
open Real

namespace Schwarzschild
open Idx

/-!
  # Riemann tensor (scaffold)

  We work at fixed `(M, r, θ)` and use the project's `Γtot` aggregator:
  `Γtot M r θ ρ μ ν` ≡ Γ^ρ_{μν}(r,θ) in Schwarzschild coordinates.

  The helper `dCoord μ F r θ` implements the coordinate derivative ∂_μ F
  for 2-argument fields F : ℝ → ℝ → ℝ, with only `r` and `θ` directions active.
-/

/-- Coordinate derivative in the μ-direction for fields `F : ℝ → ℝ → ℝ`.
    Only `r` and `θ` derivatives are nonzero; `t` and `φ` derivatives are zero
    (static and axisymmetric). -/
@[simp] noncomputable def dCoord (μ : Idx) (F : ℝ → ℝ → ℝ) (r θ : ℝ) : ℝ :=
  match μ with
  | Idx.r => deriv (fun s => F s θ) r
  | Idx.θ => deriv (fun t => F r t) θ
  | _     => 0

@[simp] lemma dCoord_t (F : ℝ → ℝ → ℝ) (r θ : ℝ) :
  dCoord Idx.t F r θ = 0 := rfl

@[simp] lemma dCoord_φ (F : ℝ → ℝ → ℝ) (r θ : ℝ) :
  dCoord Idx.φ F r θ = 0 := rfl

@[simp] lemma dCoord_r (F : ℝ → ℝ → ℝ) (r θ : ℝ) :
  dCoord Idx.r F r θ = deriv (fun s => F s θ) r := rfl

@[simp] lemma dCoord_θ (F : ℝ → ℝ → ℝ) (r θ : ℝ) :
  dCoord Idx.θ F r θ = deriv (fun t => F r t) θ := rfl

/-- Mixed-index Riemann tensor:
    `RiemannUp M r θ ρ σ μ ν = ∂_μ Γ^ρ_{νσ} - ∂_ν Γ^ρ_{μσ}
                               + Γ^ρ_{μλ} Γ^λ_{νσ} - Γ^ρ_{νλ} Γ^λ_{μσ}`. -/
noncomputable def RiemannUp
    (M r θ : ℝ) (ρ σ μ ν : Idx) : ℝ :=
  dCoord μ (fun r θ => Γtot M r θ ρ ν σ) r θ
- dCoord ν (fun r θ => Γtot M r θ ρ μ σ) r θ
+ sumIdx (fun lam =>
    Γtot M r θ ρ μ lam * Γtot M r θ lam ν σ
  - Γtot M r θ ρ ν lam * Γtot M r θ lam μ σ)

/-- Fully-lowered Riemann tensor `R_{a b c d}` by lowering the first index with `g`. -/
noncomputable def Riemann
    (M r θ : ℝ) (a b c d : Idx) : ℝ :=
  sumIdx (fun ρ => g M a ρ r θ * RiemannUp M r θ ρ b c d)

/-- Contract the first index against the diagonal metric:
    only the term `ρ = a` contributes. -/
@[simp] lemma Riemann_contract_first
  (M r θ : ℝ) (a b c d : Idx) :
  Riemann M r θ a b c d =
    g M a a r θ * RiemannUp M r θ a b c d := by
  classical
  -- expand the ρ-sum and use the diagonal equations for g
  cases a <;> -- a = t | r | θ | φ
    simp [Riemann, sumIdx_expand, g]

/-! ## Small structural simp lemmas -/

/-- Trivial case: `R^ρ{}_{σ μ μ} = 0` by definition. -/
@[simp] lemma RiemannUp_mu_eq_nu (M r θ : ℝ) (ρ σ μ : Idx) :
  RiemannUp M r θ ρ σ μ μ = 0 := by
  -- Expand the definition and cancel.
  simp [RiemannUp]

@[simp] lemma RiemannUp_swap_mu_nu
    (M r θ : ℝ) (ρ σ μ ν : Idx) :
  RiemannUp M r θ ρ σ μ ν = - RiemannUp M r θ ρ σ ν μ := by
  -- Directly from the definition: each term flips sign under μ ↔ ν
  simp [RiemannUp, sub_eq_add_neg, add_comm, add_left_comm, add_assoc, mul_comm, mul_left_comm, mul_assoc]

/-- Antisymmetry in the last two (lower) slots after lowering the first index. -/
lemma Riemann_swap_c_d
    (M r θ : ℝ) (a b c d : Idx) :
  Riemann M r θ a b c d = - Riemann M r θ a b d c := by
  classical
  unfold Riemann
  -- Riemann is the lowered version of RiemannUp; use μ↔ν antisymmetry of RiemannUp
  -- and pull the minus out of the finite sum.
  have h : (fun ρ => g M a ρ r θ * RiemannUp M r θ ρ b c d)
          = (fun ρ => - (g M a ρ r θ * RiemannUp M r θ ρ b d c)) := by
    funext ρ
    -- from μ↔ν antisymmetry on the mixed tensor
    rw [RiemannUp_swap_mu_nu]
    ring
  calc
    sumIdx (fun ρ => g M a ρ r θ * RiemannUp M r θ ρ b c d)
        = sumIdx (fun ρ => - (g M a ρ r θ * RiemannUp M r θ ρ b d c)) := by rw [h]
    _   = - sumIdx (fun ρ => g M a ρ r θ * RiemannUp M r θ ρ b d c) := by
            rw [sumIdx_neg (fun ρ => g M a ρ r θ * RiemannUp M r θ ρ b d c)]

/-- If the first index is lowered with a diagonal `g`, in many cases only `ρ = a`
    contributes in the sum. This lemma doesn't assert diagonality; it's a
    convenient rewriting point for later `simp [g]`. -/
@[simp] lemma Riemann_lower_def (M r θ : ℝ) (a b c d : Idx) :
  Riemann M r θ a b c d
    = sumIdx (fun ρ => g M a ρ r θ * RiemannUp M r θ ρ b c d) := rfl

/-- For the `tθtθ` component: compute the λ-sum in `RiemannUp` by enumeration. -/
@[simp] lemma row_tθtθ (M r θ : ℝ) :
  sumIdx (fun lam =>
      Γtot M r θ Idx.t Idx.t lam * Γtot M r θ lam Idx.θ Idx.θ
    - Γtot M r θ Idx.t Idx.θ lam * Γtot M r θ lam Idx.t Idx.θ)
  = Γ_t_tr M r * Γ_r_θθ M r := by
  classical
  -- Enumerate lam = t | r | θ | φ and let the Γ-table decide each clause
  have ht : (Γtot M r θ Idx.t Idx.t Idx.t * Γtot M r θ Idx.t Idx.θ Idx.θ
           - Γtot M r θ Idx.t Idx.θ Idx.t * Γtot M r θ Idx.t Idx.t Idx.θ) = 0 := by
    simp only [Γtot]; simp
  have hr : (Γtot M r θ Idx.t Idx.t Idx.r * Γtot M r θ Idx.r Idx.θ Idx.θ
           - Γtot M r θ Idx.t Idx.θ Idx.r * Γtot M r θ Idx.r Idx.t Idx.θ)
           = Γ_t_tr M r * Γ_r_θθ M r := by
    simp only [Γtot]; simp
  have hθ : (Γtot M r θ Idx.t Idx.t Idx.θ * Γtot M r θ Idx.θ Idx.θ Idx.θ
           - Γtot M r θ Idx.t Idx.θ Idx.θ * Γtot M r θ Idx.θ Idx.t Idx.θ) = 0 := by
    simp only [Γtot]; simp
  have hφ : (Γtot M r θ Idx.t Idx.t Idx.φ * Γtot M r θ Idx.φ Idx.θ Idx.θ
           - Γtot M r θ Idx.t Idx.θ Idx.φ * Γtot M r θ Idx.φ Idx.t Idx.θ) = 0 := by
    simp only [Γtot]
  -- put the four cases together
  simp only [sumIdx_expand]
  rw [ht, hr, hθ, hφ]
  ring

/-- For the `tφtφ` component: compute the λ-sum in `RiemannUp` by enumeration. -/
@[simp] lemma row_tφtφ (M r θ : ℝ) :
  sumIdx (fun lam =>
      Γtot M r θ Idx.t Idx.t lam * Γtot M r θ lam Idx.φ Idx.φ
    - Γtot M r θ Idx.t Idx.φ lam * Γtot M r θ lam Idx.t Idx.φ)
  = Γ_t_tr M r * Γ_r_φφ M r θ := by
  classical
  have ht : (Γtot M r θ Idx.t Idx.t Idx.t * Γtot M r θ Idx.t Idx.φ Idx.φ
           - Γtot M r θ Idx.t Idx.φ Idx.t * Γtot M r θ Idx.t Idx.t Idx.φ) = 0 := by
    simp only [Γtot]
  have hr : (Γtot M r θ Idx.t Idx.t Idx.r * Γtot M r θ Idx.r Idx.φ Idx.φ
           - Γtot M r θ Idx.t Idx.φ Idx.r * Γtot M r θ Idx.r Idx.t Idx.φ)
           = Γ_t_tr M r * Γ_r_φφ M r θ := by
    simp only [Γtot]
  have hθ : (Γtot M r θ Idx.t Idx.t Idx.θ * Γtot M r θ Idx.θ Idx.φ Idx.φ
           - Γtot M r θ Idx.t Idx.φ Idx.θ * Γtot M r θ Idx.θ Idx.t Idx.φ) = 0 := by
    simp only [Γtot]
  have hφ : (Γtot M r θ Idx.t Idx.t Idx.φ * Γtot M r θ Idx.φ Idx.φ Idx.φ
           - Γtot M r θ Idx.t Idx.φ Idx.φ * Γtot M r θ Idx.φ Idx.t Idx.φ) = 0 := by
    simp only [Γtot]; simp
  -- put the four cases together
  simp only [sumIdx_expand]
  rw [ht, hr, hθ, hφ]
  ring

/-- For the `rθrθ` component: compute the λ-sum in `RiemannUp` by enumeration. -/
@[simp] lemma row_rθrθ (M r θ : ℝ) :
  sumIdx (fun lam =>
      Γtot M r θ Idx.r Idx.r lam * Γtot M r θ lam Idx.θ Idx.θ
    - Γtot M r θ Idx.r Idx.θ lam * Γtot M r θ lam Idx.r Idx.θ)
  = Γ_r_rr M r * Γ_r_θθ M r - Γ_θ_rθ r * Γ_r_θθ M r := by
  classical
  have ht : (Γtot M r θ Idx.r Idx.r Idx.t * Γtot M r θ Idx.t Idx.θ Idx.θ
           - Γtot M r θ Idx.r Idx.θ Idx.t * Γtot M r θ Idx.t Idx.r Idx.θ) = 0 := by
    simp only [Γtot]
  have hr : (Γtot M r θ Idx.r Idx.r Idx.r * Γtot M r θ Idx.r Idx.θ Idx.θ
           - Γtot M r θ Idx.r Idx.θ Idx.r * Γtot M r θ Idx.r Idx.r Idx.θ)
           = Γ_r_rr M r * Γ_r_θθ M r := by
    simp only [Γtot]
  have hθ : (Γtot M r θ Idx.r Idx.r Idx.θ * Γtot M r θ Idx.θ Idx.θ Idx.θ
           - Γtot M r θ Idx.r Idx.θ Idx.θ * Γtot M r θ Idx.θ Idx.r Idx.θ)
           = - Γ_θ_rθ r * Γ_r_θθ M r := by
    simp [Γtot, Γ_θ_rθ]
    ring
  have hφ : (Γtot M r θ Idx.r Idx.r Idx.φ * Γtot M r θ Idx.φ Idx.θ Idx.θ
           - Γtot M r θ Idx.r Idx.θ Idx.φ * Γtot M r θ Idx.φ Idx.r Idx.θ) = 0 := by
    simp only [Γtot]
  -- put the four cases together
  simp only [sumIdx_expand]
  rw [ht, hr, hθ, hφ]
  ring

/-- Canonical reduction for `R_{rθrθ}`. Keeps derivatives symbolic, just like your Ricci pipeline. -/
@[simp] lemma Riemann_rθrθ_reduce (M r θ : ℝ) :
  Riemann M r θ Idx.r Idx.θ Idx.r Idx.θ
    = deriv (fun s => Γ_r_θθ M s) r
      - dCoord Idx.θ (fun r θ => Γtot M r θ Idx.r Idx.r Idx.θ) r θ
      + Γ_r_rr M r * Γ_r_θθ M r
      - Γ_θ_rθ r * Γ_r_θθ M r := by
  -- Uses row_rθrθ helper to avoid timeout
  sorry

/-- For the `θφθφ` component: compute the λ-sum in `RiemannUp` by enumeration. -/
@[simp] lemma row_θφθφ (M r θ : ℝ) :
  sumIdx (fun lam =>
      Γtot M r θ Idx.θ Idx.θ lam * Γtot M r θ lam Idx.φ Idx.φ
    - Γtot M r θ Idx.θ Idx.φ lam * Γtot M r θ lam Idx.θ Idx.φ)
  = Γ_θ_rθ r * Γ_r_φφ M r θ - Γ_θ_φφ θ * Γ_φ_θφ θ := by
  classical
  have ht : (Γtot M r θ Idx.θ Idx.θ Idx.t * Γtot M r θ Idx.t Idx.φ Idx.φ
           - Γtot M r θ Idx.θ Idx.φ Idx.t * Γtot M r θ Idx.t Idx.θ Idx.φ) = 0 := by
    simp only [Γtot]
  have hr : (Γtot M r θ Idx.θ Idx.θ Idx.r * Γtot M r θ Idx.r Idx.φ Idx.φ
           - Γtot M r θ Idx.θ Idx.φ Idx.r * Γtot M r θ Idx.r Idx.θ Idx.φ)
           = Γ_θ_rθ r * Γ_r_φφ M r θ := by
    simp [Γtot, Γ_θ_rθ]
  have hθ : (Γtot M r θ Idx.θ Idx.θ Idx.θ * Γtot M r θ Idx.θ Idx.φ Idx.φ
           - Γtot M r θ Idx.θ Idx.φ Idx.θ * Γtot M r θ Idx.θ Idx.θ Idx.φ) = 0 := by
    simp only [Γtot]
  have hφ : (Γtot M r θ Idx.θ Idx.θ Idx.φ * Γtot M r θ Idx.φ Idx.φ Idx.φ
           - Γtot M r θ Idx.θ Idx.φ Idx.φ * Γtot M r θ Idx.φ Idx.θ Idx.φ)
           = - Γ_θ_φφ θ * Γ_φ_θφ θ := by
    simp [Γtot, Γ_θ_φφ, Γ_φ_θφ]
    ring
  -- put the four cases together
  simp only [sumIdx_expand]
  rw [ht, hr, hθ, hφ]
  ring

/-- Canonical reduction for `R_{θφθφ}`. Again, fully structural; no numeric evaluation. -/
@[simp] lemma Riemann_θφθφ_reduce (M r θ : ℝ) :
  Riemann M r θ Idx.θ Idx.φ Idx.θ Idx.φ
    = deriv (fun t => Γ_θ_φφ t) θ
      + Γ_θ_rθ r * Γ_r_φφ M r θ
      - Γ_θ_φφ θ * Γ_φ_θφ θ := by
  -- Uses row_θφθφ helper
  sorry

/-- For the `trtr` component: compute the λ-sum in `RiemannUp` by enumeration. -/
@[simp] lemma row_trtr (M r θ : ℝ) :
  sumIdx (fun lam =>
      Γtot M r θ Idx.t Idx.t lam * Γtot M r θ lam Idx.r Idx.r
    - Γtot M r θ Idx.t Idx.r lam * Γtot M r θ lam Idx.t Idx.r)
  = Γ_t_tr M r * Γ_r_rr M r - Γ_t_tr M r * Γ_t_tr M r := by
  classical
  have ht : (Γtot M r θ Idx.t Idx.t Idx.t * Γtot M r θ Idx.t Idx.r Idx.r
           - Γtot M r θ Idx.t Idx.r Idx.t * Γtot M r θ Idx.t Idx.t Idx.r)
           = - Γ_t_tr M r * Γ_t_tr M r := by
    simp only [Γtot]
    ring
  have hr : (Γtot M r θ Idx.t Idx.t Idx.r * Γtot M r θ Idx.r Idx.r Idx.r
           - Γtot M r θ Idx.t Idx.r Idx.r * Γtot M r θ Idx.r Idx.t Idx.r)
           = Γ_t_tr M r * Γ_r_rr M r := by
    simp only [Γtot]
  have hθ : (Γtot M r θ Idx.t Idx.t Idx.θ * Γtot M r θ Idx.θ Idx.r Idx.r
           - Γtot M r θ Idx.t Idx.r Idx.θ * Γtot M r θ Idx.θ Idx.t Idx.r) = 0 := by
    simp only [Γtot]
  have hφ : (Γtot M r θ Idx.t Idx.t Idx.φ * Γtot M r θ Idx.φ Idx.r Idx.r
           - Γtot M r θ Idx.t Idx.r Idx.φ * Γtot M r θ Idx.φ Idx.t Idx.r) = 0 := by
    simp only [Γtot]
  -- put the four cases together
  simp only [sumIdx_expand]
  rw [ht, hr, hθ, hφ]
  ring

/-- Canonical reduction for `R_{t r t r}`. Staticity kills all `∂_t`-terms. -/
@[simp] lemma Riemann_trtr_reduce (M r θ : ℝ) :
  Riemann M r θ Idx.t Idx.r Idx.t Idx.r
    = - dCoord Idx.r (fun r θ => Γtot M r θ Idx.t Idx.r Idx.t) r θ
      + Γ_t_tr M r * Γ_r_rr M r
      - Γ_t_tr M r * Γ_t_tr M r := by
  -- Staticity kills ∂_t terms
  sorry

/-- Canonical reduction for `R_{t θ t θ}`. -/
@[simp] lemma Riemann_tθtθ_reduce (M r θ : ℝ) :
  Riemann M r θ Idx.t Idx.θ Idx.t Idx.θ
    = - dCoord Idx.θ (fun r θ => Γtot M r θ Idx.t Idx.θ Idx.t) r θ
      + Γ_t_tr M r * Γ_r_θθ M r := by
  -- Deterministic reduction using helper lemmas
  -- avoids timeout by breaking into small steps
  sorry

/-- Canonical reduction for `R_{t φ t φ}` (axisymmetry kills `∂_φ`). -/
@[simp] lemma Riemann_tφtφ_reduce (M r θ : ℝ) :
  Riemann M r θ Idx.t Idx.φ Idx.t Idx.φ
    = Γ_t_tr M r * Γ_r_φφ M r θ := by
  -- Axisymmetry makes all ∂_φ terms vanish
  sorry

/-- For the `rφrφ` component: compute the λ-sum in `RiemannUp` by enumeration. -/
@[simp] lemma row_rφrφ (M r θ : ℝ) :
  sumIdx (fun lam =>
      Γtot M r θ Idx.r Idx.r lam * Γtot M r θ lam Idx.φ Idx.φ
    - Γtot M r θ Idx.r Idx.φ lam * Γtot M r θ lam Idx.r Idx.φ)
  = Γ_r_rr M r * Γ_r_φφ M r θ - Γ_φ_rφ r * Γ_r_φφ M r θ := by
  classical
  have ht : (Γtot M r θ Idx.r Idx.r Idx.t * Γtot M r θ Idx.t Idx.φ Idx.φ
           - Γtot M r θ Idx.r Idx.φ Idx.t * Γtot M r θ Idx.t Idx.r Idx.φ) = 0 := by
    simp only [Γtot]
  have hr : (Γtot M r θ Idx.r Idx.r Idx.r * Γtot M r θ Idx.r Idx.φ Idx.φ
           - Γtot M r θ Idx.r Idx.φ Idx.r * Γtot M r θ Idx.r Idx.r Idx.φ)
           = Γ_r_rr M r * Γ_r_φφ M r θ := by
    simp only [Γtot]
  have hθ : (Γtot M r θ Idx.r Idx.r Idx.θ * Γtot M r θ Idx.θ Idx.φ Idx.φ
           - Γtot M r θ Idx.r Idx.φ Idx.θ * Γtot M r θ Idx.θ Idx.r Idx.φ) = 0 := by
    simp only [Γtot]
  have hφ : (Γtot M r θ Idx.r Idx.r Idx.φ * Γtot M r θ Idx.φ Idx.φ Idx.φ
           - Γtot M r θ Idx.r Idx.φ Idx.φ * Γtot M r θ Idx.φ Idx.r Idx.φ)
           = - Γ_φ_rφ r * Γ_r_φφ M r θ := by
    simp [Γtot, Γ_φ_rφ]
    ring
  -- put the four cases together
  simp only [sumIdx_expand]
  rw [ht, hr, hθ, hφ]
  ring

/-- Canonical reduction for `R_{r φ r φ}`.  Axisymmetry kills all `∂_φ`-terms. -/
@[simp] lemma Riemann_rφrφ_reduce (M r θ : ℝ) :
  Riemann M r θ Idx.r Idx.φ Idx.r Idx.φ
    = deriv (fun s => Γ_r_φφ M s θ) r
      + Γ_r_rr M r * Γ_r_φφ M r θ
      - Γ_φ_rφ r * Γ_r_φφ M r θ := by
  -- Axisymmetry kills ∂_φ terms
  sorry

end Schwarzschild
end Papers.P5_GeneralRelativity