
===== Riemann.lean:8848 =====
 8845	        (neg_mul_right₀ (RiemannUp M r θ b a μ ν) (g M b b r θ)).symm
 8846	
 8847	    -- Finish: collapse LHS inner e-sum and apply RHS contraction
 8848	    simpa [hneg_b, hcomm, hR] using ΓΓ_cross_collapse_b M r θ μ ν a b
 8849	
 8850	  have hb :
 8851	    (sumIdx B_b)

===== Riemann.lean:8855 =====
 8852	    - sumIdx (fun ρ => (Γtot M r θ ρ μ a) * (nabla_g M r θ ν ρ b))
 8853	    + sumIdx (fun ρ => (Γtot M r θ ρ ν a) * (nabla_g M r θ μ ρ b))
 8854	  =
 8855	    - sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ) := by
 8856	    classical
 8857	
 8858	    -- 0) Open only the outer shells; keep sums atomic.

===== Riemann.lean:9005 =====
 9002	            + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν a)
 9003	            - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ a) ))
 9004	      -- `-(E * g) = (-E) * g` on both sides.
 9005	      simpa [neg_mul_right₀] using this
 9006	
 9007	    /- 3) Final scalar packaging -/
 9008	    have scalar_finish :

===== Riemann.lean:9020 =====
 9017	               - dCoord ν (fun r θ => Γtot M r θ ρ μ a) r θ
 9018	               + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν a)
 9019	               - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ a) )
 9020	              * g M ρ b r θ ) := by
 9021	      intro ρ
 9022	      ring
 9023	

===== Riemann.lean:9037 =====
 9034	               * g M ρ b r θ) := by
 9035	        simp only [nabla_g, RiemannUp, sub_eq_add_neg]
 9036	        have H := sumIdx_congr scalar_finish
 9037	        exact H
 9038	      _   = - sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ)
 9039	          + rho_core_b := by
 9040	        simp only [h_rho_core_b]

===== Riemann.lean:9041 =====
 9038	      _   = - sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ)
 9039	          + rho_core_b := by
 9040	        simp only [h_rho_core_b]
 9041	        rw [h_insert_delta_for_b, ← sumIdx_add_distrib]
 9042	        apply sumIdx_congr; intro ρ
 9043	        simp only [RiemannUp]
 9044	        split_ifs with h_rho_eq_b

===== Riemann.lean:9072 =====
 9069	      + sumIdx (fun ρ => (Γtot M r θ ρ ν b) * (nabla_g M r θ μ a ρ))
 9070	    =
 9071	      - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ)
 9072	      + rho_core_a := by
 9073	    classical
 9074	
 9075	    -- Paul's outer-sum δ-insertion pattern (left-δ variant for g_{aρ})

===== Riemann.lean:9123 =====
 9120	    - sumIdx (fun ρ => (Γtot M r θ ρ μ b) * (nabla_g M r θ ν a ρ))
 9121	    + sumIdx (fun ρ => (Γtot M r θ ρ ν b) * (nabla_g M r θ μ a ρ))
 9122	  =
 9123	    - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ) := by
 9124	    classical
 9125	
 9126	    -- 0) Open only the outer shells; keep sums atomic.

===== Riemann.lean:9271 =====
 9268	            - dCoord ν (fun r θ => Γtot M r θ ρ μ b) r θ
 9269	            + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν b)
 9270	            - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ b) ))
 9271	      simpa [neg_mul_left₀] using this
 9272	
 9273	    /- 3) Final scalar packaging -/
 9274	    have scalar_finish :

===== Riemann.lean:9286 =====
 9283	               - dCoord ν (fun r θ => Γtot M r θ ρ μ b) r θ
 9284	               + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν b)
 9285	               - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ b) )
 9286	              * g M a ρ r θ ) := by
 9287	      intro ρ
 9288	      ring
 9289	

===== Riemann.lean:9304 =====
 9301	        simp only [nabla_g, RiemannUp, sub_eq_add_neg]
 9302	        have H := sumIdx_congr scalar_finish
 9303	        -- deterministically normalize the scalar shell; no binder algebra
 9304	        exact H
 9305	      _   = - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ)
 9306	          + rho_core_a := by
 9307	        simp only [h_rho_core_a]

===== Riemann.lean:9308 =====
 9305	      _   = - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ)
 9306	          + rho_core_a := by
 9307	        simp only [h_rho_core_a]
 9308	        rw [h_insert_delta_for_a, ← sumIdx_add_distrib]
 9309	        apply sumIdx_congr; intro ρ
 9310	        simp only [RiemannUp]
 9311	        split_ifs with h_rho_eq_a

===== Riemann.lean:9348 =====
 9345	      - sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ)
 9346	    - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ) := by
 9347	    calc
 9348	      ((sumIdx B_b) - sumIdx (fun ρ => (Γtot M r θ ρ μ a) * (nabla_g M r θ ν ρ b))
 9349	                    + sumIdx (fun ρ => (Γtot M r θ ρ ν a) * (nabla_g M r θ μ ρ b)))
 9350	      + ((sumIdx B_a) - sumIdx (fun ρ => (Γtot M r θ ρ μ b) * (nabla_g M r θ ν a ρ))
 9351	                    + sumIdx (fun ρ => (Γtot M r θ ρ ν b) * (nabla_g M r θ μ a ρ)))

===== Riemann.lean:9353 =====
 9350	      + ((sumIdx B_a) - sumIdx (fun ρ => (Γtot M r θ ρ μ b) * (nabla_g M r θ ν a ρ))
 9351	                    + sumIdx (fun ρ => (Γtot M r θ ρ ν b) * (nabla_g M r θ μ a ρ)))
 9352	        = (- sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ) + rho_core_b)
 9353	        + (- sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ) + rho_core_a) := by
 9354	          -- Fold both helpers forward
 9355	          simp [hb_plus, ha_plus]
 9356	      -- Flatten the 4-term outer sum deterministically

===== Riemann.lean:9594 =====
 9591	          (sumIdx (fun e =>
 9592	            Γtot M r θ e μ b * dCoord ν (fun r θ => g M a e r θ) r θ
 9593	          - Γtot M r θ e ν b * dCoord μ (fun r θ => g M a e r θ) r θ)) := hsplit
 9594	    _   = 0 := h_cancel
 9595	
 9596	/-! ### Block C: Main to Commutator -/
 9597	

===== Riemann.lean:9795 =====
 9792	  have hP0 : A + B + C + D = 0 := by
 9793	    -- FIX (Option 2): Use the flipped variant.
 9794	    -- Since the definitions of A, B, C, D match the lemma exactly, `exact` should work.
 9795	    exact payload_cancel_all_flipped M r θ h_ext μ ν a b
 9796	
 9797	  -- A3: Collapse the four-sum payload in one shot:
 9798	  have h_payload_zero :

===== Riemann.lean:9809 =====
 9806	    simpa [A, B, C, D] using h_payload_flip.trans hP0
 9807	
 9808	  -- Use the equality; avoid recursive simp loops
 9809	  rw [h_payload_zero]
 9810	  simp only [zero_add, add_zero, sub_zero]  -- stable cleanup only
 9811	
 9812	  -- Steps 6-8: Apply remaining blocks to simplify the rest of the goal.

===== Riemann.lean:9878 =====
 9875	  have h_θ' : nabla_g M r θ Idx.θ a b = 0 := nabla_g_zero_ext M r θ h_ext Idx.θ a b
 9876	  have LHS0 :
 9877	    dCoord Idx.r (fun r θ => nabla_g M r θ Idx.θ a b) r θ
 9878	  - dCoord Idx.θ (fun r θ => nabla_g M r θ Idx.r a b) r θ = 0 := by
 9879	    -- both dCoord terms are derivatives of the constant 0
 9880	    simp [h_r, h_θ', dCoord]
 9881	    ring

===== Riemann.lean:9989 =====
 9986	  have hν : nabla_g M r θ ν a b = 0 := nabla_g_zero_ext M r θ h_ext ν a b
 9987	  have LHS0 :
 9988	    dCoord μ (fun r θ => nabla_g M r θ ν a b) r θ
 9989	  - dCoord ν (fun r θ => nabla_g M r θ μ a b) r θ = 0 := by
 9990	    simp [hμ, hν, dCoord]
 9991	    ring
 9992	
