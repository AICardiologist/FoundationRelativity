  /- SECOND BLOCK (no h_plus/h_minus; no recursive simp) -/
  -- define the two ρ-bodies once (ASCII names; no Unicode)
  let U : Idx → ℝ :=
    fun ρ => sumIdx (fun e => Γtot M r θ ρ μ b * Γtot M r θ e ν a)
  let V : Idx → ℝ :=
    fun ρ => sumIdx (fun e => Γtot M r θ ρ ν b * Γtot M r θ e μ a)

  have second_block :
    sumIdx (fun ρ =>
      sumIdx (fun e =>
        ((Γtot M r θ ρ μ b * Γtot M r θ e ν a)
       - (Γtot M r θ ρ ν b * Γtot M r θ e μ a)) * g M ρ e r θ))
    =
    sumIdx (fun ρ => g M ρ a r θ * (U ρ - V ρ)) := by
    -- pointwise reshaping of the inner subtraction; one `sumIdx_map_sub`
    apply sumIdx_congr; intro ρ
    have : (fun e =>
      ((Γtot M r θ ρ μ b * Γtot M r θ e ν a)
     - (Γtot M r θ ρ ν b * Γtot M r θ e μ a)) * g M ρ e r θ)
         = (fun e =>
             (Γtot M r θ ρ μ b * Γtot M r θ e ν a) * g M ρ e r θ
           - (Γtot M r θ ρ ν b * Γtot M r θ e μ a) * g M ρ e r θ) := by
      funext e; ring
    simp [this, sumIdx_map_sub, U, V, fold_sub_right, mul_comm, mul_left_comm, mul_assoc]

  -- collapse the outer ρ-sum by diagonality (after one symmetry flip)
  have U_collapse :
    sumIdx (fun ρ => g M ρ a r θ * U ρ) = g M a a r θ * U a := by
    have : sumIdx (fun ρ => g M ρ a r θ * U ρ)
         = sumIdx (fun ρ => g M a ρ r θ * U ρ) := by
      apply sumIdx_congr; intro ρ; simpa [g_symm_JP M r θ ρ a]
    simpa [this] using
      (sumIdx_reduce_by_diagonality M r θ a (fun ρ => U ρ))

  have V_collapse :
    sumIdx (fun ρ => g M ρ a r θ * V ρ) = g M a a r θ * V a := by
    have : sumIdx (fun ρ => g M ρ a r θ * V ρ)
         = sumIdx (fun ρ => g M a ρ r θ * V ρ) := by
      apply sumIdx_congr; intro ρ; simpa [g_symm_JP M r θ ρ a]
    simpa [this] using
      (sumIdx_reduce_by_diagonality M r θ a (fun ρ => V ρ))

  -- final algebra
  have split_outer :
    sumIdx (fun ρ => g M ρ a r θ * (U ρ - V ρ))
      = sumIdx (fun ρ => g M ρ a r θ * U ρ)
      - sumIdx (fun ρ => g M ρ a r θ * V ρ) := by
    have : (fun ρ => g M ρ a r θ * (U ρ - V ρ))
         = (fun ρ => g M ρ a r θ * U ρ - g M ρ a r θ * V ρ) := by
      funext ρ; simp [fold_sub_right, mul_comm, mul_left_comm, mul_assoc]
    simpa [this, sumIdx_map_sub]

  have second_block_closed :
    sumIdx (fun ρ => g M ρ a r θ * (U ρ - V ρ))
    =
    g M a a r θ *
      ( U a - V a ) := by
    calc
      sumIdx (fun ρ => g M ρ a r θ * (U ρ - V ρ))
          = sumIdx (fun ρ => g M ρ a r θ * U ρ)
            - sumIdx (fun ρ => g M ρ a r θ * V ρ) := split_outer
      _   = g M a a r θ * U a - g M a a r θ * V a := by
              rw [U_collapse, V_collapse]
      _   = g M a a r θ * (U a - V a) := by ring

  -- rewrite the bodies at ρ = a
  have second_block_final :
    g M a a r θ * (U a - V a)
    =
    g M a a r θ *
      ( sumIdx (fun e => Γtot M r θ a μ b * Γtot M r θ e ν a)
      - sumIdx (fun e => Γtot M r θ a ν b * Γtot M r θ e μ a) ) := by
    simp [U, V]

  -- conclude the second block in the original shape
  have second_block :
    sumIdx (fun ρ => sumIdx (fun e =>
      ((Γtot M r θ ρ μ b * Γtot M r θ e ν a)
     - (Γtot M r θ ρ ν b * Γtot M r θ e μ a)) * g M ρ e r θ))
    =
    g M a a r θ *
      ( sumIdx (fun e => Γtot M r θ a μ b * Γtot M r θ e ν a)
      - sumIdx (fun e => Γtot M r θ a ν b * Γtot M r θ e μ a) ) := by
    -- plug the chain above
    have := second_block
    -- (name shadowing avoided by using second_block_closed/final above)
    exact
      (by
        -- first identify with the "g ρb * (U−V)" form
        have := (by exact (second_block : _))
        -- then collapse and unfold U/V at ρ = a
        simpa using
          (second_block_closed.trans second_block_final))
