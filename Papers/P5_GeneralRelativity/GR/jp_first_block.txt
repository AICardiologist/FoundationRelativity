  /- FIRST BLOCK (no H₁/H₂; no recursive simp) -/
  have first_block :
    sumIdx (fun ρ => sumIdx (fun e =>
      ((Γtot M r θ ρ μ a * Γtot M r θ e ν ρ)
     - (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ)) * g M e b r θ))
    =
    g M b b r θ *
      ( sumIdx (fun ρ => Γtot M r θ ρ μ a * Γtot M r θ b ν ρ)
      - sumIdx (fun ρ => Γtot M r θ ρ ν a * Γtot M r θ b μ ρ) ) := by
    -- distribute the inner subtraction per ρ, then lift Σ across it once
    have step₁ :
      ∀ ρ,
        sumIdx (fun e =>
          ((Γtot M r θ ρ μ a * Γtot M r θ e ν ρ)
         - (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ)) * g M e b r θ)
        =
        (sumIdx (fun e => (Γtot M r θ ρ μ a * Γtot M r θ e ν ρ) * g M e b r θ))
        - (sumIdx (fun e => (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ) * g M e b r θ)) := by
      intro ρ
      have : (fun e =>
        ((Γtot M r θ ρ μ a * Γtot M r θ e ν ρ)
       - (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ)) * g M e b r θ)
           = (fun e =>
               (Γtot M r θ ρ μ a * Γtot M r θ e ν ρ) * g M e b r θ
             - (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ) * g M e b r θ) := by
        funext e; ring
      simpa [this, sumIdx_map_sub]

    have step₁' :
      sumIdx (fun ρ => sumIdx (fun e =>
        ((Γtot M r θ ρ μ a * Γtot M r θ e ν ρ)
       - (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ)) * g M e b r θ))
      =
      sumIdx (fun ρ =>
        (sumIdx (fun e => (Γtot M r θ ρ μ a * Γtot M r θ e ν ρ) * g M e b r θ))
        - (sumIdx (fun e => (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ) * g M e b r θ))) := by
      apply sumIdx_congr; intro ρ; simpa using step₁ ρ

    -- collapse each e‑sum by diagonality after swapping g's indices, then factor g_{bb}
    have reduce₊ :
      sumIdx (fun ρ => sumIdx (fun e =>
        (Γtot M r θ ρ μ a * Γtot M r θ e ν ρ) * g M e b r θ))
      =
      g M b b r θ * sumIdx (fun ρ => Γtot M r θ ρ μ a * Γtot M r θ b ν ρ) := by
      have inner :
        ∀ ρ,
          sumIdx (fun e =>
            (Γtot M r θ ρ μ a * Γtot M r θ e ν ρ) * g M e b r θ)
          =
          Γtot M r θ ρ μ a *
            sumIdx (fun e => g M b e r θ * Γtot M r θ e ν ρ) := by
        intro ρ
        calc
          sumIdx (fun e =>
            (Γtot M r θ ρ μ a * Γtot M r θ e ν ρ) * g M e b r θ)
              = sumIdx (fun e =>
                  Γtot M r θ ρ μ a * (g M b e r θ * Γtot M r θ e ν ρ)) := by
                apply sumIdx_congr; intro e
                have := g_symm_JP M r θ e b
                simp [this, mul_comm, mul_left_comm, mul_assoc]
              _ = Γtot M r θ ρ μ a *
                    sumIdx (fun e => g M b e r θ * Γtot M r θ e ν ρ) := by
                simpa using
                  (sumIdx_mul (Γtot M r θ ρ μ a)
                    (fun e => g M b e r θ * Γtot M r θ e ν ρ))
      calc
        sumIdx (fun ρ => sumIdx (fun e =>
          (Γtot M r θ ρ μ a * Γtot M r θ e ν ρ) * g M e b r θ))
            = sumIdx (fun ρ =>
                Γtot M r θ ρ μ a *
                  sumIdx (fun e => g M b e r θ * Γtot M r θ e ν ρ)) := by
              apply sumIdx_congr; intro ρ; simpa using inner ρ
        _   = sumIdx (fun ρ =>
                Γtot M r θ ρ μ a * (g M b b r θ * Γtot M r θ b ν ρ)) := by
              apply sumIdx_congr; intro ρ
              simpa using
                (sumIdx_reduce_by_diagonality M r θ b
                  (fun e => Γtot M r θ e ν ρ))
        _   = g M b b r θ *
                sumIdx (fun ρ => Γtot M r θ ρ μ a * Γtot M r θ b ν ρ) := by
              simpa [sumIdx_mul, mul_comm, mul_left_comm, mul_assoc]

    have reduce₋ :
      sumIdx (fun ρ => sumIdx (fun e =>
        (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ) * g M e b r θ))
      =
      g M b b r θ * sumIdx (fun ρ => Γtot M r θ ρ ν a * Γtot M r θ b μ ρ) := by
      have inner :
        ∀ ρ,
          sumIdx (fun e =>
            (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ) * g M e b r θ)
          =
          Γtot M r θ ρ ν a *
            sumIdx (fun e => g M b e r θ * Γtot M r θ e μ ρ) := by
        intro ρ
        calc
          sumIdx (fun e =>
            (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ) * g M e b r θ)
              = sumIdx (fun e =>
                  Γtot M r θ ρ ν a * (g M b e r θ * Γtot M r θ e μ ρ)) := by
                apply sumIdx_congr; intro e
                have := g_symm_JP M r θ e b
                simp [this, mul_comm, mul_left_comm, mul_assoc]
              _ = Γtot M r θ ρ ν a *
                    sumIdx (fun e => g M b e r θ * Γtot M r θ e μ ρ) := by
                simpa using
                  (sumIdx_mul (Γtot M r θ ρ ν a)
                    (fun e => g M b e r θ * Γtot M r θ e μ ρ))
      calc
        sumIdx (fun ρ => sumIdx (fun e =>
          (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ) * g M e b r θ))
            = sumIdx (fun ρ =>
                Γtot M r θ ρ ν a *
                  sumIdx (fun e => g M b e r θ * Γtot M r θ e μ ρ)) := by
              apply sumIdx_congr; intro ρ; simpa using inner ρ
        _   = sumIdx (fun ρ =>
                Γtot M r θ ρ ν a * (g M b b r θ * Γtot M r θ b μ ρ)) := by
              apply sumIdx_congr; intro ρ
              simpa using
                (sumIdx_reduce_by_diagonality M r θ b
                  (fun e => Γtot M r θ e μ ρ))
        _   = g M b b r θ *
                sumIdx (fun ρ => Γtot M r θ ρ ν a * Γtot M r θ b μ ρ) := by
              simpa [sumIdx_mul, mul_comm, mul_left_comm, mul_assoc]

    -- assemble
    calc
      sumIdx (fun ρ => sumIdx (fun e =>
        ((Γtot M r θ ρ μ a * Γtot M r θ e ν ρ)
       - (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ)) * g M e b r θ))
          = _ := step₁'
      _ = (g M b b r θ * sumIdx (fun ρ => Γtot M r θ ρ μ a * Γtot M r θ b ν ρ))
          - (g M b b r θ * sumIdx (fun ρ => Γtot M r θ ρ ν a * Γtot M r θ b μ ρ)) := by
        rw [reduce₊, reduce₋]
      _ = g M b b r θ *
            ( sumIdx (fun ρ => Γtot M r θ ρ μ a * Γtot M r θ b ν ρ)
            - sumIdx (fun ρ => Γtot M r θ ρ ν a * Γtot M r θ b μ ρ) ) := by
        ring
