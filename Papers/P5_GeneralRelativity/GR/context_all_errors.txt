### Context for line 6081 (lines 6071-6091)
     1	      intro ρ
     2	      -- Expand the fᵢ and fold deterministically; then recognize RiemannUp
     3	      -- Key: we factor `g M a ρ r θ` over (dr - dθ) and the (ΣΓΓ - ΣΓΓ) block.
     4	      -- The ring tactic handles `g*X - g*Y = g*(X - Y)` and `g*X + g*Y = g*(X + Y)`.
     5	      have : f₁ ρ - f₂ ρ + f₃ ρ - f₄ ρ
     6	          = g M a ρ r θ *
     7	              ( dCoord Idx.r (fun r θ => Γtot M r θ ρ Idx.θ b) r θ
     8	              - dCoord Idx.θ (fun r θ => Γtot M r θ ρ Idx.r b) r θ
     9	              + sumIdx (fun lam =>
    10	                  Γtot M r θ ρ Idx.r lam * Γtot M r θ lam Idx.θ b
    11	                - Γtot M r θ ρ Idx.θ lam * Γtot M r θ lam Idx.r b) ) := by
    12	        -- expand fᵢ, then linear algebra
    13	        simp [f₁, f₂, f₃, f₄]
    14	        ring
    15	      -- Now fold to `g * RiemannUp …` using the definition
    16	      simpa [RiemannUp] using this
    17	
    18	    have step5 :
    19	      ((A - B) + (M_r - M_θ)) + (Extra_r - Extra_θ)
    20	      =
    21	      sumIdx (fun ρ => g M a ρ r θ * RiemannUp M r θ ρ b Idx.r Idx.θ)

### Context for line 7533 (lines 7523-7543)
     1	  =
     2	    -- bb-core
     3	    ( g M b b r θ
     4	        * (  sumIdx (fun e => Γtot M r θ b μ e * Γtot M r θ e ν a)
     5	           -  sumIdx (fun e => Γtot M r θ b ν e * Γtot M r θ e μ a) ) )
     6	  +
     7	    -- ρρ-core (to be cancelled by the a-branch later)
     8	    ( sumIdx (fun ρ =>
     9	        g M ρ ρ r θ
    10	        * (   Γtot M r θ ρ μ a * Γtot M r θ ρ ν b
    11	            - Γtot M r θ ρ ν a * Γtot M r θ ρ μ b )) ) := by
    12	  classical
    13	  /- FIRST BLOCK (deterministic; no reduce_plus/minus; no recursive simp) -/
    14	  have first_block :
    15	    sumIdx (fun ρ => sumIdx (fun e =>
    16	      ((Γtot M r θ ρ μ a * Γtot M r θ e ν ρ)
    17	     - (Γtot M r θ ρ ν a * Γtot M r θ e μ ρ)) * g M e b r θ))
    18	    =
    19	    sumIdx (fun ρ =>
    20	      g M b b r θ * (Γtot M r θ ρ μ a * Γtot M r θ b ν ρ)
    21	    - g M b b r θ * (Γtot M r θ ρ ν a * Γtot M r θ b μ ρ)) := by

### Context for line 7835 (lines 7825-7845)
     1	        ((Γtot M r θ ρ μ b * Γtot M r θ e ν a)
     2	       - (Γtot M r θ ρ ν b * Γtot M r θ e μ a)) * g M ρ e r θ)) )
     3	  =
     4	    ( g M a a r θ
     5	        * (  sumIdx (fun e => Γtot M r θ a μ e * Γtot M r θ e ν b)
     6	           -  sumIdx (fun e => Γtot M r θ a ν e * Γtot M r θ e μ b) ) )
     7	  +
     8	    ( sumIdx (fun ρ =>
     9	        g M ρ ρ r θ
    10	        * (   Γtot M r θ ρ μ b * Γtot M r θ ρ ν a
    11	            - Γtot M r θ ρ ν b * Γtot M r θ ρ μ a )) ) := by
    12	  classical
    13	  -- Identical proof to ΓΓ_quartet_split_b, with `a` and `b` swapped
    14	  /- FIRST BLOCK (deterministic; no reduce_plus/minus; no recursive simp) -/
    15	  have first_block :
    16	    sumIdx (fun ρ => sumIdx (fun e =>
    17	      ((Γtot M r θ ρ μ b * Γtot M r θ e ν ρ)
    18	     - (Γtot M r θ ρ ν b * Γtot M r θ e μ ρ)) * g M e a r θ))
    19	    =
    20	    sumIdx (fun ρ =>
    21	      g M a a r θ * (Γtot M r θ ρ μ b * Γtot M r θ a ν ρ)

### Context for line 8637 (lines 8627-8647)
     1	    -- (ΣB_b − ΣX) + ΣY = Σ (B_b − X) + ΣY = Σ ((B_b − X) + Y)
     2	    rw [hCμa, hCνa]
     3	    rw [← sumIdx_map_sub B_b (fun ρ => (Γtot M r θ ρ μ a) * (nabla_g M r θ ν ρ b))]
     4	    rw [← sumIdx_add_distrib]
     5	
     6	  have hb :
     7	    (sumIdx B_b)
     8	    - sumIdx (fun ρ => (Γtot M r θ ρ μ a) * (nabla_g M r θ ν ρ b))
     9	    + sumIdx (fun ρ => (Γtot M r θ ρ ν a) * (nabla_g M r θ μ ρ b))
    10	  =
    11	    - sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ) := by
    12	    classical
    13	
    14	    -- 0) Open only the outer shells; keep sums atomic.
    15	    simp only [nabla_g, RiemannUp, sub_eq_add_neg]
    16	
    17	    /- 1) Cancel the Γ·∂g payload at Σ_ρ level.
    18	          Keep it at Σ_ρ and use a tiny scalar `ring` under `sumIdx_congr`. -/
    19	    have payload_cancel :
    20	      sumIdx (fun ρ =>
    21	        (-(Γtot M r θ ρ ν a) * dCoord μ (fun r θ => g M ρ b r θ) r θ

### Context for line 8787 (lines 8777-8797)
     1	            - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ a) ) * g M ρ b r θ)
     2	        * (if ρ = b then 1 else 0)) := by
     3	      classical
     4	      -- Put the minus inside to match the helper F·g shape, then insert δ in one shot.
     5	      have := insert_delta_right_diag M r θ b (fun ρ =>
     6	        - ( dCoord μ (fun r θ => Γtot M r θ ρ ν a) r θ
     7	            - dCoord ν (fun r θ => Γtot M r θ ρ μ a) r θ
     8	            + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν a)
     9	            - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ a) ))
    10	      -- `-(E * g) = (-E) * g` on both sides.
    11	      simpa [neg_mul_right₀] using this
    12	
    13	    /- 3) Final scalar packaging -/
    14	    have scalar_finish :
    15	      ∀ ρ,
    16	        ( -(dCoord μ (fun r θ => Γtot M r θ ρ ν a) r θ) * g M ρ b r θ
    17	          +  (dCoord ν (fun r θ => Γtot M r θ ρ μ a) r θ) * g M ρ b r θ )
    18	        +  ( g M ρ b r θ *
    19	              ( sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν a)
    20	               -sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ a) ) )
    21	        =

### Context for line 8802 (lines 8792-8812)
     1	        ( -(dCoord μ (fun r θ => Γtot M r θ ρ ν a) r θ) * g M ρ b r θ
     2	          +  (dCoord ν (fun r θ => Γtot M r θ ρ μ a) r θ) * g M ρ b r θ )
     3	        +  ( g M ρ b r θ *
     4	              ( sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν a)
     5	               -sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ a) ) )
     6	        =
     7	          - ( ( dCoord μ (fun r θ => Γtot M r θ ρ ν a) r θ
     8	               - dCoord ν (fun r θ => Γtot M r θ ρ μ a) r θ
     9	               + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν a)
    10	               - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ a) )
    11	              * g M ρ b r θ ) := by
    12	      intro ρ
    13	      ring
    14	
    15	    /- 4) Assemble to get hb_partial with rho_core_b -/
    16	    calc
    17	      (sumIdx B_b)
    18	    - sumIdx (fun ρ => (Γtot M r θ ρ μ a) * (nabla_g M r θ ν ρ b))
    19	    + sumIdx (fun ρ => (Γtot M r θ ρ ν a) * (nabla_g M r θ μ ρ b))
    20	        = sumIdx (fun ρ =>
    21	              - ( dCoord μ (fun r θ => Γtot M r θ ρ ν a) r θ

### Context for line 8819 (lines 8809-8829)
     1	    - sumIdx (fun ρ => (Γtot M r θ ρ μ a) * (nabla_g M r θ ν ρ b))
     2	    + sumIdx (fun ρ => (Γtot M r θ ρ ν a) * (nabla_g M r θ μ ρ b))
     3	        = sumIdx (fun ρ =>
     4	              - ( dCoord μ (fun r θ => Γtot M r θ ρ ν a) r θ
     5	                 - dCoord ν (fun r θ => Γtot M r θ ρ μ a) r θ
     6	                 + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν a)
     7	                 - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ a) )
     8	               * g M ρ b r θ) := by
     9	        simp only [nabla_g, RiemannUp, sub_eq_add_neg]
    10	        have H := sumIdx_congr scalar_finish
    11	        exact H
    12	      _   = - sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ)
    13	          + rho_core_b := by
    14	        simp only [h_rho_core_b]
    15	        rw [h_insert_delta_for_b, ← sumIdx_add_distrib]
    16	        apply sumIdx_congr; intro ρ
    17	        simp only [RiemannUp]
    18	        split_ifs with h_rho_eq_b
    19	        · -- ρ = b case
    20	          subst h_rho_eq_b
    21	          simp only [h_bb_core]

### Context for line 8823 (lines 8813-8833)
     1	                 - dCoord ν (fun r θ => Γtot M r θ ρ μ a) r θ
     2	                 + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν a)
     3	                 - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ a) )
     4	               * g M ρ b r θ) := by
     5	        simp only [nabla_g, RiemannUp, sub_eq_add_neg]
     6	        have H := sumIdx_congr scalar_finish
     7	        exact H
     8	      _   = - sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ)
     9	          + rho_core_b := by
    10	        simp only [h_rho_core_b]
    11	        rw [h_insert_delta_for_b, ← sumIdx_add_distrib]
    12	        apply sumIdx_congr; intro ρ
    13	        simp only [RiemannUp]
    14	        split_ifs with h_rho_eq_b
    15	        · -- ρ = b case
    16	          subst h_rho_eq_b
    17	          simp only [h_bb_core]
    18	          rw [← scalar_finish_bb]
    19	          ring
    20	        · -- ρ ≠ b case: Kronecker δ = 0
    21	          simp

### Context for line 8852 (lines 8842-8862)
     1	        + (Γtot M r θ ρ ν b) * (nabla_g M r θ μ a ρ)) := by
     2	    rw [hCμb, hCνb]
     3	    rw [← sumIdx_map_sub B_a (fun ρ => (Γtot M r θ ρ μ b) * (nabla_g M r θ ν a ρ))]
     4	    rw [← sumIdx_add_distrib]
     5	
     6	  have ha :
     7	    (sumIdx B_a)
     8	    - sumIdx (fun ρ => (Γtot M r θ ρ μ b) * (nabla_g M r θ ν a ρ))
     9	    + sumIdx (fun ρ => (Γtot M r θ ρ ν b) * (nabla_g M r θ μ a ρ))
    10	  =
    11	    - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ) := by
    12	    classical
    13	
    14	    -- 0) Open only the outer shells; keep sums atomic.
    15	    simp only [nabla_g, RiemannUp, sub_eq_add_neg]
    16	
    17	    /- 1) Cancel the Γ·∂g payload at Σ_ρ level. -/
    18	    have payload_cancel :
    19	      sumIdx (fun ρ =>
    20	        (-(Γtot M r θ ρ ν b) * dCoord μ (fun r θ => g M a ρ r θ) r θ
    21	          + (Γtot M r θ ρ μ b) * dCoord ν (fun r θ => g M a ρ r θ) r θ)

### Context for line 9000 (lines 8990-9010)
     1	            - dCoord ν (fun r θ => Γtot M r θ ρ μ b) r θ
     2	            + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν b)
     3	            - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ b) ) * g M a ρ r θ)
     4	        * (if ρ = a then 1 else 0)) := by
     5	      classical
     6	      have := insert_delta_left_diag M r θ a (fun ρ =>
     7	        - ( dCoord μ (fun r θ => Γtot M r θ ρ ν b) r θ
     8	            - dCoord ν (fun r θ => Γtot M r θ ρ μ b) r θ
     9	            + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν b)
    10	            - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ b) ))
    11	      simpa [neg_mul_left₀] using this
    12	
    13	    /- 3) Final scalar packaging -/
    14	    have scalar_finish :
    15	      ∀ ρ,
    16	        ( -(dCoord μ (fun r θ => Γtot M r θ ρ ν b) r θ) * g M a ρ r θ
    17	          +  (dCoord ν (fun r θ => Γtot M r θ ρ μ b) r θ) * g M a ρ r θ )
    18	        +  ( g M a ρ r θ *
    19	              ( sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν b)
    20	               -sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ b) ) )
    21	        =

### Context for line 9015 (lines 9005-9025)
     1	        ( -(dCoord μ (fun r θ => Γtot M r θ ρ ν b) r θ) * g M a ρ r θ
     2	          +  (dCoord ν (fun r θ => Γtot M r θ ρ μ b) r θ) * g M a ρ r θ )
     3	        +  ( g M a ρ r θ *
     4	              ( sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν b)
     5	               -sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ b) ) )
     6	        =
     7	          - ( ( dCoord μ (fun r θ => Γtot M r θ ρ ν b) r θ
     8	               - dCoord ν (fun r θ => Γtot M r θ ρ μ b) r θ
     9	               + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν b)
    10	               - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ b) )
    11	              * g M a ρ r θ ) := by
    12	      intro ρ
    13	      ring
    14	
    15	    /- 4) Assemble to get ha_partial with rho_core_a -/
    16	    calc
    17	      (sumIdx B_a)
    18	    - sumIdx (fun ρ => (Γtot M r θ ρ μ b) * (nabla_g M r θ ν a ρ))
    19	    + sumIdx (fun ρ => (Γtot M r θ ρ ν b) * (nabla_g M r θ μ a ρ))
    20	        = sumIdx (fun ρ =>
    21	              - ( dCoord μ (fun r θ => Γtot M r θ ρ ν b) r θ

### Context for line 9033 (lines 9023-9043)
     1	    + sumIdx (fun ρ => (Γtot M r θ ρ ν b) * (nabla_g M r θ μ a ρ))
     2	        = sumIdx (fun ρ =>
     3	              - ( dCoord μ (fun r θ => Γtot M r θ ρ ν b) r θ
     4	                 - dCoord ν (fun r θ => Γtot M r θ ρ μ b) r θ
     5	                 + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν b)
     6	                 - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ b) )
     7	               * g M a ρ r θ) := by
     8	        simp only [nabla_g, RiemannUp, sub_eq_add_neg]
     9	        have H := sumIdx_congr scalar_finish
    10	        -- deterministically normalize the scalar shell; no binder algebra
    11	        exact H
    12	      _   = - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ)
    13	          + rho_core_a := by
    14	        simp only [h_rho_core_a]
    15	        rw [h_insert_delta_for_a, ← sumIdx_add_distrib]
    16	        apply sumIdx_congr; intro ρ
    17	        simp only [RiemannUp]
    18	        split_ifs with h_rho_eq_a
    19	        · -- ρ = a case
    20	          subst h_rho_eq_a
    21	          simp only [h_aa_core]

### Context for line 9037 (lines 9027-9047)
     1	                 + sumIdx (fun e => Γtot M r θ ρ μ e * Γtot M r θ e ν b)
     2	                 - sumIdx (fun e => Γtot M r θ ρ ν e * Γtot M r θ e μ b) )
     3	               * g M a ρ r θ) := by
     4	        simp only [nabla_g, RiemannUp, sub_eq_add_neg]
     5	        have H := sumIdx_congr scalar_finish
     6	        -- deterministically normalize the scalar shell; no binder algebra
     7	        exact H
     8	      _   = - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ)
     9	          + rho_core_a := by
    10	        simp only [h_rho_core_a]
    11	        rw [h_insert_delta_for_a, ← sumIdx_add_distrib]
    12	        apply sumIdx_congr; intro ρ
    13	        simp only [RiemannUp]
    14	        split_ifs with h_rho_eq_a
    15	        · -- ρ = a case
    16	          subst h_rho_eq_a
    17	          simp only [h_aa_core]
    18	          rw [← scalar_finish_aa]
    19	          ring
    20	        · -- ρ ≠ a case: Kronecker δ = 0
    21	          simp

### Context for line 9078 (lines 9068-9088)
     1	    - sumIdx (fun ρ => (Γtot M r θ ρ μ a) * (nabla_g M r θ ν ρ b))
     2	    + sumIdx (fun ρ => (Γtot M r θ ρ ν a) * (nabla_g M r θ μ ρ b))
     3	    + (sumIdx B_a)
     4	    - sumIdx (fun ρ => (Γtot M r θ ρ μ b) * (nabla_g M r θ ν a ρ))
     5	    + sumIdx (fun ρ => (Γtot M r θ ρ ν b) * (nabla_g M r θ μ a ρ))
     6	    =
     7	      - sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ)
     8	    - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ) := by
     9	    calc
    10	      _ = ( - sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ) + rho_core_b )
    11	        + ( - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ) + rho_core_a ) := by
    12	        rw [← hb, ← ha]
    13	      _ = - sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ)
    14	        - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ)
    15	        + (rho_core_b + rho_core_a) := by
    16	        ring
    17	      _ = - sumIdx (fun ρ => RiemannUp M r θ ρ a μ ν * g M ρ b r θ)
    18	        - sumIdx (fun ρ => RiemannUp M r θ ρ b μ ν * g M a ρ r θ) := by
    19	        rw [diag_cancel]; ring
    20	
    21	  -- 8) Assemble: two scalar rings, no heavy rewriting.

### Context for line 9249 (lines 9239-9259)
     1	  = 0 := by
     2	  -- Strategy: Flip factors back to match the input format of payload_cancel_all,
     3	  -- then apply the existing cancellation lemma.
     4	  -- The goal has factors in `dCoord * Γtot` order (flipped).
     5	  -- We need to transform to `Γtot * dCoord` order (unflipped) to match payload_cancel_all.
     6	
     7	  -- Use commutativity of multiplication and properties of negation
     8	  simp only [neg_mul, mul_comm (dCoord _ _ _ _)]
     9	
    10	  -- Now the structure matches payload_cancel_all, with AC normalization
    11	  simpa [add_assoc, add_comm, add_left_comm] using (payload_cancel_all M r θ h_ext μ ν a b)
    12	
    13	/-! ### Block C: Main to Commutator -/
    14	
    15	/-- Block C: C'_main equals the ΓΓ commutator part of RHS.
    16	    Uses: sum swapping, index relabeling, metric symmetry, and commutativity. -/
    17	lemma main_to_commutator (M r θ : ℝ) (h_ext : Exterior M r θ) (μ ν a b : Idx) :
    18	  -- LHS: main from expand_Ca and expand_Cb (Formula A with e as upper index)
    19	  ( sumIdx (fun ρ => sumIdx (fun e =>
    20	      Γtot M r θ ρ μ a * Γtot M r θ e ν ρ * g M e b r θ
    21	    - Γtot M r θ ρ ν a * Γtot M r θ e μ ρ * g M e b r θ)) )

### Context for line 9464 (lines 9454-9474)
     1	    sumIdx (fun e =>
     2	        - Γtot M r θ e ν a * dCoord μ (fun r θ => g M e b r θ) r θ
     3	      - Γtot M r θ e ν b * dCoord μ (fun r θ => g M a e r θ) r θ
     4	      + Γtot M r θ e μ a * dCoord ν (fun r θ => g M e b r θ) r θ
     5	      + Γtot M r θ e μ b * dCoord ν (fun r θ => g M a e r θ) r θ)
     6	    = 0 := by
     7	    -- Use A1 then A2, no extra simplification.
     8	    simpa [A, B, C, D] using h_payload_flip.trans hP0
     9	
    10	  -- Use the equality; avoid recursive simp loops
    11	  rw [h_payload_zero]
    12	  simp only [zero_add, add_zero, sub_zero]  -- stable cleanup only
    13	
    14	  -- Steps 6-8: Apply remaining blocks to simplify the rest of the goal.
    15	  -- A2: normalize the ∂Γ–metric cluster inside the binder so `dGamma_match` matches syntactically.
    16	  have hΓshape :
    17	    sumIdx (fun e =>
    18	        - dCoord μ (fun r θ => Γtot M r θ e ν a) r θ * g M e b r θ
    19	      +   dCoord ν (fun r θ => Γtot M r θ e μ a) r θ * g M e b r θ
    20	      -   dCoord μ (fun r θ => Γtot M r θ e ν b) r θ * g M a e r θ
    21	      +   dCoord ν (fun r θ => Γtot M r θ e μ b) r θ * g M a e r θ)

### Context for line 9533 (lines 9523-9543)
     1	  - Riemann M r θ b a Idx.r Idx.θ - Riemann M r θ a b Idx.r Idx.θ := by
     2	  classical
     3	  -- General Ricci identity at (μ,ν) = (r,θ)
     4	  have H := ricci_identity_on_g_general M r θ h_ext h_θ Idx.r Idx.θ a b
     5	
     6	  -- Kill the commutator LHS by metric compatibility (∇g = 0)
     7	  have h_r : nabla_g M r θ Idx.r a b = 0 := nabla_g_zero_ext M r θ h_ext Idx.r a b
     8	  have h_θ' : nabla_g M r θ Idx.θ a b = 0 := nabla_g_zero_ext M r θ h_ext Idx.θ a b
     9	  have LHS0 :
    10	    dCoord Idx.r (fun r θ => nabla_g M r θ Idx.θ a b) r θ
    11	  - dCoord Idx.θ (fun r θ => nabla_g M r θ Idx.r a b) r θ = 0 := by
    12	    -- both dCoord terms are derivatives of the constant 0
    13	    simp [h_r, h_θ', dCoord]
    14	    ring
    15	
    16	  -- Convert both Σ(RUp⋅g) terms to lowered Riemann
    17	  have S₁ :
    18	    sumIdx (fun ρ => RiemannUp M r θ ρ a Idx.r Idx.θ * g M ρ b r θ)
    19	      = Riemann M r θ b a Idx.r Idx.θ :=
    20	    sum_RUp_g_to_Riemann_ba M r θ a b Idx.r Idx.θ
    21	  have S₂ :

### Context for line 9644 (lines 9634-9654)
     1	  (M r θ : ℝ) (h_ext : Exterior M r θ) (hθ : Real.sin θ ≠ 0)
     2	  (a b μ ν : Idx) :
     3	  Riemann M r θ a b μ ν = - Riemann M r θ b a μ ν := by
     4	  classical
     5	  have H := ricci_identity_on_g_general M r θ h_ext hθ μ ν a b
     6	  -- ∇g = 0 on Exterior
     7	  have hμ : nabla_g M r θ μ a b = 0 := nabla_g_zero_ext M r θ h_ext μ a b
     8	  have hν : nabla_g M r θ ν a b = 0 := nabla_g_zero_ext M r θ h_ext ν a b
     9	  have LHS0 :
    10	    dCoord μ (fun r θ => nabla_g M r θ ν a b) r θ
    11	  - dCoord ν (fun r θ => nabla_g M r θ μ a b) r θ = 0 := by
    12	    simp [hμ, hν, dCoord]
    13	    ring
    14	
    15	  -- Convert the two Σ(RUp⋅g) to Riemann
    16	  have S₁ := sum_RUp_g_to_Riemann_ba M r θ a b μ ν
    17	  have S₂ := sum_RUp_g_to_Riemann_ab M r θ a b μ ν
    18	
    19	  -- Kill Gamma terms by metric compatibility
    20	  have hμν :
    21	    Gamma_mu_nabla_nu M r θ μ ν a b = 0 := by

