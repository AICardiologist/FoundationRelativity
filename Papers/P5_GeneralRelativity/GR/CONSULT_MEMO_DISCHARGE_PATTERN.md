# Brief Tactical Clarification: Nested Condition Localization Discharge

**To:** Professor
**From:** AI Development Team
**Date:** October 1, 2025
**Subject:** Discharge Pattern for Nested Condition Localization in dCoord_ContractionC_expanded

---

## Status

**Sequential Rewrite Strategy:** ✅ Implemented successfully
**Robust Discharge with `case`:** ⏳ Blocked on nested Condition Localization

---

## Specific Issue

After implementing your Sequential Rewrite pattern, we hit a tactical issue with the Robust Discharge in step 1 (ROBUST DISCHARGE 1).

### Current Code (Lines 1829-1831)

```lean
case hF_r => intros k
             apply DifferentiableAt_r_add_of_cond
             all_goals { apply DifferentiableAt_r_mul_of_cond <;> discharge_diff }
```

### What Happens

**After `intros k`:** Goal is `DifferentiableAt_r (fun r θ => Γ·g + Γ·g) r θ ∨ μ ≠ Idx.r`

**After `apply DifferentiableAt_r_add_of_cond`:** 2 goals:
```
⊢ DifferentiableAt_r (fun r θ => Γ(k,c,a) * g(k,b)) r θ ∨ μ ≠ Idx.r
⊢ DifferentiableAt_r (fun r θ => Γ(k,c,b) * g(a,k)) r θ ∨ μ ≠ Idx.r
```

**After `all_goals { apply DifferentiableAt_r_mul_of_cond }`:** 4 goals per product (8 total):
```
-- First product:
⊢ DifferentiableAt_r (fun r θ => Γtot M r θ k c a) r θ ∨ μ ≠ Idx.r  -- hA from first product
⊢ DifferentiableAt_r (fun r θ => g M k b r θ) r θ ∨ μ ≠ Idx.r      -- hB from first product

-- Second product:
⊢ DifferentiableAt_r (fun r θ => Γtot M r θ k c b) r θ ∨ μ ≠ Idx.r  -- hA from second product
⊢ DifferentiableAt_r (fun r θ => g M a k r θ) r θ ∨ μ ≠ Idx.r      -- hB from second product
```

**When we apply `discharge_diff` to these goals:**

**Error:** "`simp` made no progress"

The goals have structure `DifferentiableAt_r (fun r θ => Γ...) r θ ∨ μ ≠ Idx.r`, but discharge_diff's simp with `Γtot_differentiable_r` isn't matching them.

---

## Question

**What's the correct discharge pattern for these 4 goals?**

**Option A:** Apply `Or.inl` first, then discharge?
```lean
all_goals { apply DifferentiableAt_r_mul_of_cond }
all_goals { try { apply Or.inl; simp [Γtot_differentiable_r, differentiableAt_g_...] } }
```

**Option B:** Use specific @[simp] form?
```lean
all_goals { apply DifferentiableAt_r_mul_of_cond }
all_goals { simp only [Γtot_differentiable_r, differentiableAt_g_tt_r, ...] }
```

**Option C:** Manual application?
```lean
all_goals { apply DifferentiableAt_r_mul_of_cond }
· exact Γtot_differentiable_r M r θ k c a
· exact differentiableAt_g_...
· exact Γtot_differentiable_r M r θ k c b
· exact differentiableAt_g_...
```

**Option D:** Different approach entirely?

---

## What We've Tried

1. `<;> discharge_diff` → simp made no progress
2. `<;> (try discharge_diff)` → simp made no progress
3. `<;> (apply Or.inl; discharge_diff)` → simp made no progress

The core issue: discharge_diff relies on simp, but simp isn't matching the goal structure after the Condition Localization lemmas are applied.

---

## Request

Please provide the exact tactical pattern for lines 1829-1834 to discharge the hypotheses generated by nested Condition Localization applications.

---

**Current file state:** Riemann.lean lines 1807-1867 (dCoord_ContractionC_expanded proof)
**Build status:** Failing with 5+ "`simp` made no progress" errors in ROBUST DISCHARGE 1 and 2
