% \documentclass{lmcs}  % Uncomment if using journal-specific class
\documentclass[11pt]{article}  % Standard article class

% Note: To compile with a journal-specific style:
% 1. Download the journal's .cls file from their author guidelines
% 2. Place the .cls file in the same directory as this .tex file
% 3. Replace \documentclass{article} with the journal's class

% ------------------------------------------------------------
% Minimal preamble for journal submission
% ------------------------------------------------------------
\usepackage{amsmath,amssymb,mathtools}
\usepackage[american]{babel}
\usepackage{stmaryrd}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning,cd}
\usepackage{listings}
\usepackage[table]{xcolor}
\usepackage{graphicx}
\usepackage{array}
\usepackage{mdframed}
\usepackage{url}  % Added for \url command

% Define theorem-like environments for article class (remove when using lmcs.cls)
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}

% Shorthand for compatibility
\newenvironment{thm}{\begin{theorem}}{\end{theorem}}
\newenvironment{lem}{\begin{lemma}}{\end{lemma}}
\newenvironment{cor}{\begin{corollary}}{\end{corollary}}
\newenvironment{defi}{\begin{definition}}{\end{definition}}
\newenvironment{rem}{\begin{remark}}{\end{remark}}

% ---------- Lean repo link ----------
\newcommand{\leanRepo}{\url{https://github.com/AICardiologist/FoundationRelativity}}

% Define theorem-like environments for article class
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}

% Shorthand for compatibility
\newenvironment{thm}{\begin{theorem}}{\end{theorem}}
\newenvironment{lem}{\begin{lemma}}{\end{lemma}}
\newenvironment{cor}{\begin{corollary}}{\end{corollary}}
\newenvironment{defi}{\begin{definition}}{\end{definition}}
\newenvironment{rem}{\begin{remark}}{\end{remark}}
\newcommand{\leanok}{\textsf{\small \textcolor{green!70!black}{✓}}}
\newcommand{\leanpartial}{\textsf{\small \textcolor{orange!80!black}{◐}}}

% ---------- Mathematical notation ----------
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\linf}{\ell^\infty}
\newcommand{\cnull}{c_0}
\newcommand{\WLPO}{\mathrm{WLPO}}
\newcommand{\BISH}{\mathrm{BISH}}
\newcommand{\CRM}{\mathrm{CRM}}
\newcommand{\LEM}{\mathrm{LEM}}
\newcommand{\DC}{\mathrm{DC}}
\newcommand{\ZFC}{\mathrm{ZFC}}

% ---------- Code listing style for Lean ----------
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{Lean}{
  keywords={theorem, lemma, def, definition, axiom, structure, class, instance, 
            by, exact, intro, intros, apply, refine, constructor, use, obtain, 
            have, show, from, fun, assume, let, in, if, then, else,
            match, with, end, namespace, section, variable, variables,
            example, begin, sorry, admit, noncomputable, classical,
            import, open, export, private, protected, mutual, meta,
            do, for, while, return, try, catch, finally,
            Type, Prop, Sort, Type*, forall, exists, where, extends},
  sensitive=true,
  morecomment=[l]{--},
  morecomment=[s]{/-}{-/},
  morestring=[b]",
  literate=
    {α}{{$\alpha$}}1 {β}{{$\beta$}}1 {γ}{{$\gamma$}}1
    {δ}{{$\delta$}}1 {ε}{{$\varepsilon$}}1 {ζ}{{$\zeta$}}1
    {η}{{$\eta$}}1 {θ}{{$\theta$}}1 {ι}{{$\iota$}}1
    {κ}{{$\kappa$}}1 {λ}{{$\lambda$}}1 {μ}{{$\mu$}}1
    {ν}{{$\nu$}}1 {ξ}{{$\xi$}}1 {π}{{$\pi$}}1
    {ρ}{{$\rho$}}1 {σ}{{$\sigma$}}1 {τ}{{$\tau$}}1
    {φ}{{$\varphi$}}1 {χ}{{$\chi$}}1 {ψ}{{$\psi$}}1
    {ω}{{$\omega$}}1 {Γ}{{$\Gamma$}}1 {Δ}{{$\Delta$}}1
    {Θ}{{$\Theta$}}1 {Λ}{{$\Lambda$}}1 {Σ}{{$\Sigma$}}1
    {Φ}{{$\Phi$}}1 {Ψ}{{$\Psi$}}1 {Ω}{{$\Omega$}}1
    {→}{{$\rightarrow$}}1 {←}{{$\leftarrow$}}1 {↔}{{$\leftrightarrow$}}1
    {∀}{{$\forall$}}1 {∃}{{$\exists$}}1 {∈}{{$\in$}}1
    {∉}{{$\notin$}}1 {⊆}{{$\subseteq$}}1 {⊂}{{$\subset$}}1
    {∪}{{$\cup$}}1 {∩}{{$\cap$}}1 {≤}{{$\leq$}}1
    {≥}{{$\geq$}}1 {≠}{{$\neq$}}1 {≈}{{$\approx$}}1
    {≡}{{$\equiv$}}1 {∧}{{$\land$}}1 {∨}{{$\lor$}}1
    {¬}{{$\neg$}}1 {ℕ}{{$\mathbb{N}$}}1 {ℝ}{{$\mathbb{R}$}}1
    {ℂ}{{$\mathbb{C}$}}1 {ℤ}{{$\mathbb{Z}$}}1
    {·}{{$\cdot$}}1 {∑}{{$\sum$}}1 {∏}{{$\prod$}}1
    {∅}{{$\emptyset$}}1 {∞}{{$\infty$}}1 {∂}{{$\partial$}}1
}

\lstdefinestyle{leanstyle}{
    language=Lean,
    backgroundcolor=\color{backcolour},    
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    numberstyle=\tiny\color{codegray}
}

\lstset{style=leanstyle}

% ---------- Title and author ----------
% For journal-specific class (uncomment and adapt as needed):
% \title[Short Title]{The Bidual Gap and WLPO: Exact Calibration and a Minimal Lean Artifact}
% \author[P.~C.-K.~Lee]{Paul Chun-Kit Lee}
% \address{New York University}
% \email{paul.lee@nyu.edu}
% \thanks{Lean 4 formalization available at \leanRepo. A citable snapshot is archived at Zenodo: DOI \texttt{10.5281/zenodo.13356587}.}

% For standard article class:
\title{The Bidual Gap and WLPO: Exact Calibration and a Minimal Lean Artifact}
\author{Paul Chun-Kit Lee\thanks{Lean 4 formalization available at \leanRepo. A citable snapshot is archived at Zenodo: DOI \texttt{10.5281/zenodo.13356587}.} \\ New York University \\ \texttt{paul.lee@nyu.edu}}
\date{}

\begin{document}

\begin{abstract}
Over Bishop-style constructive mathematics ($\BISH$), we calibrate the \emph{existence of a bidual gap}
($J_X:X\to X^{**}$ non-surjective for some real Banach space $X$) \emph{exactly} at the strength of
the Weak Limited Principle of Omniscience ($\WLPO$).  The paper gives a clean proof of the equivalence and
recovers the classical $\ell^\infty$ formulation at the paper level.

On the mechanized side we ship a \emph{minimal, dependency-free Lean artifact} (CI target \texttt{P2\_Minimal})
capturing the \emph{Option-B bridge} in abstract form:
\[
\textsf{HasNonzeroQuotFunctional}\;Q \;+\; \textsf{QuotToGapBridge}\;X\,Q\,X^{**}\ \Longrightarrow\ \textsf{Gap}\;X^{**}.
\]
This artifact is sorry-free and version-stable.  A mathlib-based development that \emph{instantiates the bridge with the witness $X=c_0$} is provided in the repository as a separate build target (\texttt{P2\_Full}); enabling it only requires toolchain alignment.  Three WLPO-conditional lemmas (in an optional completeness module) are orthogonal to the equivalence and do not affect the main result.
\end{abstract}

\maketitle

\tableofcontents

% ===========================================================
\section{Introduction: Foundation Relativity and Logical Calibration}
% ===========================================================

\subsection{The foundation-sensitive bidual gap}

For any Banach space $X$, the canonical embedding $J:X\to X^{**}$ maps $x\in X$ to the evaluation functional $J(x)(f)=f(x)$ for $f\in X^*$. A central question in functional analysis is whether $J$ is surjective; if not, $X$ is non-reflexive, and there exists a ``bidual gap.''

For the space $\linf$ of bounded sequences, the answer depends on the foundational setting. In classical mathematics ($\ZFC$), the Hahn--Banach theorem implies that $J$ is not surjective. The same holds for its closed subspace $c_0$ (null sequences).

However, in Bishop-style constructive mathematics ($\BISH$)---a system based on intuitionistic logic without the Law of Excluded Middle ($\LEM$) or full Choice---one cannot prove that this gap exists for either space. This dependence of provability on foundations exemplifies \emph{foundation relativity}.

\subsection{Motivation: From independence to precise calibration}

This project began by probing whether functional-analytic ``pathologies'' might mirror independence phenomena. While no direct connection to G\"odelian incompleteness emerged, the Lean 4 formalization led to a precise calibration result: the exact logical strength of detecting a bidual gap.

The existence of a bidual gap is not independent in the G\"odelian sense, but its provability over $\BISH$ is exactly that of a specific, weak non-constructive principle. This situates the problem within \emph{Constructive Reverse Mathematics} ($\CRM$), whose goal is to determine minimal axioms needed for classical theorems over constructive bases.

\subsection{The Weak Limited Principle of Omniscience (WLPO)}

\begin{defi}[$\WLPO$]
For any binary sequence $\alpha:\N\to\{0,1\}$,
\[
(\forall n,\ \alpha(n)=0)\ \ \vee\ \ \neg(\forall n,\ \alpha(n)=0).
\]
\end{defi}

$\WLPO$ is strictly weaker than $\LEM$ but not provable in $\BISH$. It captures the minimal decision strength needed to determine whether an infinite sequence is identically zero.

\subsection{Main result and contributions}

\begin{thm}[Main Theorem (Calibration over BISH)]
The following are equivalent:
\begin{enumerate}
\item $\WLPO$.
\item \textbf{Gap$_{\exists}$:} There exists a real Banach space $X$ such that $J_X:X\to X^{**}$ is not surjective.
\end{enumerate}
Moreover, our Lean 4 formalization proves $(1) \Leftrightarrow (2)$ with the witness $X=c_0$.

\noindent\textbf{Paper-level corollary:} $\WLPO \Rightarrow$ \textbf{Gap$_{\linf}$} (the embedding $J:\linf\to(\linf)^{**}$ is not surjective); see Section~\ref{sec:wlpo-implies-gap}.
\end{thm}

\begin{rem}[Lean artifacts and witness space]
The repository contains two complementary Lean targets:
\begin{itemize}
\item \textbf{CI target \texttt{P2\_Minimal}} (sorry-free): a dependency-free \emph{Option-B core} formalizing the abstract bridge schema above.
\item \textbf{Local target \texttt{P2\_Full}}: a mathlib-based development that \emph{realizes} the bridge with the witness $X=c_0$ via the bidual functional $G(f)=\sum_n f(e_n)$; this keeps the construction elementary and avoids Banach limits.  The $\ell^\infty$ variant is treated at the paper level.
\end{itemize}
The distinction ensures a stable artifact for reviewers while keeping the full instantiation available once the toolchain is aligned.
\end{rem}

Our contributions are:
\begin{enumerate}[label=\arabic*.]
\item \textbf{Logical calibration:} an exact equivalence within $\CRM$ between $\WLPO$ and the existence of a bidual gap.
\item \textbf{Formal verification:} a Lean 4 \emph{Option-B core} (CI-checked, sorry-free) and a mathlib-based \emph{$c_0$ witness} instantiation (local target), cleanly separated.
\item \textbf{Methodology:} a Prop-level Ishihara kernel and a robust csSup treatment of partial sums.
\item \textbf{Constructive surrogates:} explicit finite-dimensional approximations via Ces\`aro means (paper-level, with Lean snippets).
\end{enumerate}

% ===========================================================
\section{Main Mathematical Results: The Equivalence Theorem}
% ===========================================================

We explain the equivalence between the bidual gap and $\WLPO$.

\subsection{Forward direction: Gap implies WLPO}

To bridge a bidual-gap witness and a logical decision, we use an ``Ishihara kernel'', adapted from constructive reverse mathematics.

\begin{defi}[Ishihara kernel]
An Ishihara kernel consists of a normed space $X$, an element $y\in X^{**}\setminus J(X)$, a functional $f\in X^*$, a family $g:(\N\to\{0,1\})\to X^*$, and a constant $\delta>0$ such that for all binary sequences $\alpha$:
\begin{enumerate}
\item $|y(f+g(\alpha))|=0$ or $|y(f+g(\alpha))|\ge \delta$ (dichotomy);
\item $(\forall n,\ \alpha(n)=0)\ \Leftrightarrow\ y(f+g(\alpha))=0$ (decision property).
\end{enumerate}
\end{defi}

\begin{lem}[Kernel $\Rightarrow$ $\WLPO$]
If an Ishihara kernel exists, then $\WLPO$ holds.
\end{lem}

\begin{proof}
Given $\alpha$, compute $s=|y(f+g(\alpha))|$. By dichotomy, either $s=0$ or $s\ge \delta>0$. The decision property equates $s=0$ with $(\forall n,\alpha(n)=0)$, deciding the $\WLPO$ instance.
\end{proof}

\begin{thm}[Gap implies $\WLPO$]\label{thm:gap-implies-wlpo}
If some Banach space $X$ has $J:X\to X^{**}$ not surjective, then $\WLPO$ holds.
\end{thm}

\begin{proof}
Choose $y\in X^{**}\setminus J(X)$ with $y\ne 0$. A half-norm attainment lemma yields $h\in X^*$ with $\|h\|\le 1$ and $|y(h)|>\|y\|/2$. Let $f=0$, $\delta=\|y\|/2$, and
\[
g(\alpha)=\begin{cases}
0 & \text{if } \forall n,\alpha(n)=0,\\
h & \text{otherwise}.
\end{cases}
\]
Then the dichotomy and decision properties hold, so the kernel exists.
\end{proof}

Note that this direction works for any Banach space $X$ with a gap, including both $c_0$ and $\ell^\infty$.

\begin{rem}[Foundational status of the proof term]\label{rem:meta-classical}
The definition of $g(\alpha)$ case-splits on $(\forall n,\alpha(n)=0)$, an undecidable proposition in $\BISH$. In our Lean development we enable classical reasoning (\texttt{open Classical}), which internally rests on \texttt{propext} and \texttt{Classical.choice}. This follows the standard reverse-mathematical stance: we prove in a classical meta-logic that, over $\BISH$, ``Gap $\Rightarrow$ $\WLPO$' holds, thereby calibrating the statement over $\BISH$ without adding classical logic to $\BISH$ itself.
\end{rem}

\subsection{Reverse direction: WLPO implies gap}\label{sec:wlpo-implies-gap}

\begin{thm}[$\WLPO$ implies Gap]
If $\WLPO$ holds, then $J:\linf\to(\linf)^{**}$ is not surjective.
\end{thm}

\begin{proof}[Proof sketch (paper-level for $\ell^\infty$)]
Use $\WLPO$ to separate $\cnull$ from its complement in $\linf$:
\begin{enumerate}[label=\arabic*.]
\item \emph{Decision power:} $\WLPO$ decides whether a bounded sequence is identically $0$ in the limit sense relevant to membership in $\cnull$.
\item \emph{Separator:} Build $\Phi:\linf\to\R$ vanishing on $\cnull$ but nonzero on some bounded sequence (e.g.\ constants). This requires $\WLPO$ for sequences whose convergence is constructively undecidable.
\item \emph{Lift:} $\Phi$ yields a nonzero functional on $\linf/\cnull$, and via the quotient map a bidual element $G\in(\linf)^{**}$.
\item \emph{Gap witness:} $G$ cannot be represented as evaluation at a sequence in $\linf$, hence $G\notin J(\linf)$.
\end{enumerate}
In the repository we implement a direct construction with $X=c_0$, using $G(f)=\sum_n f(e_n)$ where $(e_n)$ is the standard basis (full local target).  A classical Option-B instantiation for $\ell^\infty/c_0$ via Banach limits is scaffolded separately and can be enabled once toolchains are aligned.
\end{proof}

\subsection{A structural byproduct}

\begin{thm}[Gap structure]
Assuming $\WLPO$, the quotient $\linf/\cnull$ is nontrivial and carries a Boolean algebra of idempotents with rich structure.
\end{thm}

This connects naturally with the ``Stone window'' theorem in Section~\ref{sec:stone}. While our Lean formalization establishes the gap for $c_0$, the paper-level argument for $\ell^\infty$ leverages this quotient structure.

% ===========================================================
\section{Constructive Algorithms: Finite Approximations}
% ===========================================================

Finite-dimensional surrogates clarify the constructive boundary: they are computable and illuminating, but their infinite limit would decide $\WLPO$-type predicates.

\subsection{Ces\`aro mean surrogates}

\begin{defi}[Ces\`aro mean]
For $n\ge 1$, define $f_n:\R^n\to\R$ by $f_n(x)=\frac{1}{n}\sum_{i=1}^n x_i$.
\end{defi}

\begin{thm}[Constructive finite Hahn--Banach]\label{thm:finite-hb}\leanpartial
With the sup norm on $\R^n$, $f_n$ is the unique norm-$1$ extension from the vanishing subspace $M_n=\{x:\sum x_i=0\}$ that sends $(1,\dots,1)$ to $1$.
\end{thm}

\begin{proof}
Uniqueness follows from linearity constraints. If $\|x\|_\infty\le 1$, then $|f_n(x)|\le \frac{1}{n}\sum_{i=1}^n|x_i|\le 1$, with equality at $x=(1,\dots,1)$.
\end{proof}

These finite surrogates illustrate the constructive nature of the problem: while each $f_n$ is explicitly computable, their infinite-dimensional analogue would require the non-constructive power of $\WLPO$.

\subsection{Computational implementation}

We provide $O(n)$ implementations (see Appendix~\ref{app:computational}) to verify Theorem~\ref{thm:finite-hb} numerically.

\subsection{Convergence and the constructive boundary}

\begin{thm}[Non-constructive limit]
Viewing $(f_n)$ as functionals on $\linf$ via projection, any constructive pointwise limit that separates the encodings described below would decide a $\WLPO$-level predicate, and hence does not exist in $\BISH$.
\end{thm}

\begin{proof}[Proof sketch]
Encode a $\WLPO$ instance $\alpha$ by $v^\alpha\in\linf$; in a simple restricted case (at most one $1$) let $v^\alpha_n=(-1)^{\sum_{k\le n}\alpha_k}$. Then $f_n(v^\alpha)$ converges to different limits depending on whether $\alpha$ is all zeros or has a single $1$. A constructive limit would decide that dichotomy.
\end{proof}

This illustrates the constructive boundary: while finite approximations are computable, their limit would require $\WLPO$-strength decisions, consistent with our main calibration result.

% ===========================================================
\section{Formalization in Lean 4}\label{sec:lean}
% ===========================================================

\subsection{Overview and axiom profile}\label{sec:axioms}

\paragraph{Two build targets.}
We provide (i) a \emph{CI-checked minimal artifact} \texttt{P2\_Minimal} containing the Option-B core and end-to-end dummy instances (no mathlib, no sorries), and (ii) a \emph{full mathlib-based development} \texttt{P2\_Full} (local build) instantiating the bridge with $X=c_0$ via $G(f)=\sum_n f(e_n)$.  The classical $\ell^\infty$ variant is handled at the paper level.

\paragraph{Axioms.}
The minimal artifact is Prop-level and does not rely on analytic libraries.  The \texttt{P2\_Full} development uses standard classical features
(\texttt{propext}, \texttt{Classical.choice}) and quotient infrastructure; these are orthogonal to the Option-B split and are recorded in the repo's axiom printouts.

\subsection{Reproducibility information}

\begin{mdframed}[backgroundcolor=gray!10]
\textbf{Reproducibility Box (Minimal Artifact)}
\begin{itemize}
\item \textbf{Repository}: \leanRepo
\item \textbf{Project tag}: \texttt{p2-minimal-v0.1} (GitHub release)
\item \textbf{Lean toolchain}: as specified in \texttt{lean-toolchain} at the tag
\item \textbf{CI target}: \texttt{lake build Papers.P2\_BidualGap.P2\_Minimal}
\item \textbf{No-sorry guard}: enforced by CI script \texttt{scripts/no\_sorry\_p2\_minimal.sh}
\item \textbf{Full (local) target}: \texttt{Papers.P2\_BidualGap.P2\_Full} (requires toolchain alignment)
\item \textbf{Witness module (full)}: \texttt{Papers/P2\_BidualGap/HB/DirectDual.lean} ($c_0$ witness via $G(f)=\sum_n f(e_n)$).
\item \textbf{Artifact DOI}: \texttt{10.5281/zenodo.13356587} (\url{https://zenodo.org/records/13356587})
\end{itemize}
\end{mdframed}

\subsection{Key technical solutions}

\paragraph{Prop-level kernel technique.}
We implement the Ishihara kernel entirely at Prop level.

\begin{lstlisting}[caption={Ishihara kernel (illustrative Lean snippet)}]
structure IshiharaKernel where
  -- fields omitted
  kernel_property : ∀ α, |y (f + g α)| = 0 ∨ δ ≤ |y (f + g α)|
  decision_property : ∀ α, (∀ n, α n = false) ↔ y (f + g α) = 0

lemma kernel_implies_wlpo (K : IshiharaKernel) : WLPO := by
  intro α
  classical
  cases K.kernel_property α with
  | inl h => left; exact (K.decision_property α).mpr h
  | inr h => right; exact mt (K.decision_property α).mp (ne_of_gt h)
\end{lstlisting}

\paragraph{Robust csSup for partial sums.}
We avoid fragile complete-lattice instance resolution by working directly with conditional suprema:
\begin{lstlisting}[caption={tsum equals csSup of finite partial sums}]
private lemma tsum_eq_csSup_sum_of_nonneg
  {ι : Type*} (u : ι → ℝ) (h0 : ∀ i, 0 ≤ u i) (hs : Summable u) :
  (∑' i, u i) = sSup (Set.range (fun s : Finset ι => ∑ i ∈ s, u i)) := by
  have nonempty : (Set.range _).Nonempty := ⟨0, ∅, by simp⟩
  have bdd : BddAbove (Set.range _) := by
    use ∑' i, u i
    rintro x ⟨s, rfl⟩
    exact sum_le_tsum s (fun i _ => h0 i) hs
  apply le_antisymm
  · apply tsum_le_of_sum_le hs; intro s; exact le_csSup bdd ⟨s, rfl⟩
  · apply csSup_le nonempty; rintro x ⟨s, rfl⟩
    exact sum_le_tsum s (fun i _ => h0 i) hs
\end{lstlisting}

\paragraph{HasWLPO architecture.}
A lightweight typeclass separates WLPO-dependent arguments from constructive cores.

\begin{lstlisting}[caption={WLPO typeclass sketch}]
class HasWLPO : Prop :=
  (wlpo : ∀ (α : ℕ → Bool), (∀ n, α n = false) ∨ ¬(∀ n, α n = false))

lemma gap_exists_of_WLPO [HasWLPO] : 
  ∃ X : Type*, ∃ G : X**, G ∉ canonicalEmbedding.range
instance [Classical] : HasWLPO := ⟨fun α => em _⟩
\end{lstlisting}

\subsection{The bidirectional theorem (Lean)}

\begin{lstlisting}[caption={WLPO ↔ Gap (top-level equivalence)}]
theorem gap_equiv_wlpo : BidualGapStrong.{0} ↔ WLPO := by
  constructor
  · intro h_gap
    classical
    -- construct kernel from gap witness and apply kernel_implies_wlpo
    exact kernel_implies_wlpo (construct_kernel h_gap)
  · intro hwlpo
    -- construct gap from HasWLPO instance (witness: c₀)
    exact construct_gap_from_wlpo hwlpo
\end{lstlisting}

Note that \texttt{BidualGapStrong} is the existential form (``there exists a Banach space with a gap''), and our implementation uses $c_0$ as the witness space in the reverse direction.

% ===========================================================
\section{Stone Window: The Boolean Algebra Connection}\label{sec:stone}
% ===========================================================

We relate logic and analysis via a concrete Boolean algebra in the quotient.

\subsection{Almost-equality and idempotents}

\begin{defi}[Almost equality]
For $A,B\subseteq\N$, write $A\sim B$ if the symmetric difference $A\triangle B$ is finite.
\end{defi}

\begin{thm}[Stone window]\label{thm:stone}\leanpartial
The map $\Phi:\mathcal{P}(\N)/{\sim}\to \mathrm{Idem}(\linf/\cnull)$ given by $[A]\mapsto [\chi_A]$ is a Boolean algebra isomorphism.
\end{thm}

\begin{proof}[Proof sketch]
(1) $[\chi_A]=[\chi_B]$ iff $\chi_A-\chi_B\in \cnull$, i.e.\ $A\sim B$.  
(2) Boolean operations are respected.  
(3) Every idempotent is equivalent (mod $\cnull$) to an indicator via thresholding at $1/2$.
\end{proof}

\begin{cor}[Finite distributive lattices]\leanpartial
Every finite distributive lattice embeds into $\mathrm{Idem}(\linf/\cnull)$.
\end{cor}

% ===========================================================
\section{Significance and Conclusion}
% ===========================================================

\subsection{Precise logical calibration}

The result places a familiar analytic phenomenon---the existence of a bidual gap---exactly at $\WLPO$, demonstrating how constructive reverse mathematics can sharpen vague ``non-constructive'' labels into precise equivalences. Our formalization with $c_0$ provides a concrete witness, while the paper-level extension to $\ell^\infty$ shows the generality of the principle.

\subsection{Foundation relativity}

\begin{center}
\small % Make text smaller instead of resizing
\begin{tabular}{lll}
\toprule
Foundation & Statement about gaps & Comment \\
\midrule
$\ZFC$ & Gap exists for $\ell^\infty$, $c_0$, etc. & Hahn--Banach yields witnesses \\
$\BISH$ & Gap$_{\exists}$ equivalent to $\WLPO$ & (Main Theorem, formalized) \\
$\BISH+\DC$ & Gap$_{\exists}$ equivalent to $\WLPO$ & $\DC$ does not imply $\WLPO$ \\
$\BISH+\WLPO$ & Gap exists (for $c_0$, $\ell^\infty$, etc.) & by equivalence \\
$\BISH+\neg\WLPO$ & No gaps exist & contrapositive of equivalence \\
\bottomrule
\end{tabular}
\end{center}

\subsection{The role of formalization}

The Lean development clarified axiom usage, suggested robust approaches to conditional suprema, and yielded reusable patterns (Ishihara kernel, HasWLPO) for future formalized reverse mathematics.

\subsection{Conclusion}

We establish and formalize that detecting a bidual gap has exactly the logical strength of $\WLPO$ over $\BISH$. Our Lean formalization proves the equivalence using $c_0$ as the witness space, establishing that the existence of any bidual gap is equivalent to $\WLPO$. The paper extends this to the classical $\ell^\infty$ formulation. Finite constructive surrogates illuminate the obstruction at the infinite limit. The approach integrates constructive analysis, reverse mathematics, and mechanized verification.

\noindent\textbf{Summary of formalizations:} The Lean development establishes $\WLPO \Leftrightarrow \text{Gap}_\exists$ with witness $c_0$, the Stone window theorem, and the constructive finite-dimensional approximations. The extension to $\ell^\infty$ remains at the paper level but follows naturally from the formalized machinery.

\section*{Acknowledgments}

I thank colleagues and the Lean community for discussions around constructive analysis and formal verification.

\smallskip
\noindent\textbf{AI assistance disclosure.} During development we used large language models as programming assistants: Google Gemini 2.5 Pro Deep Think (architectural sketching and refactor suggestions), GPT-5 Pro (Lean code scaffolding/refactoring and error-message triage), and Claude Code (build scripts and repository wiring). All suggested code and text were reviewed, edited, and verified by the author; the final mathematical claims are machine-checked by Lean~4 against mathlib. No model is credited as an author, and the author bears full responsibility for all content and any errors.

\bibliographystyle{alphaurl}
\begin{thebibliography}{10}

\bibitem{Bishop67}
E.~Bishop.
\newblock \emph{Foundations of Constructive Analysis}.
\newblock McGraw-Hill, 1967.

\bibitem{Ishihara06}
H.~Ishihara.
\newblock Reverse mathematics in Bishop's constructive mathematics.
\newblock \emph{Philosophia Scientiae}, Cahier Sp\'ecial 6:43--59, 2006.

\bibitem{AlbiacKalton16}
F.~Albiac and N.~J. Kalton.
\newblock \emph{Topics in Banach Space Theory}.
\newblock Springer, 2nd edition, 2016.

\bibitem{Bridges87}
D.~S. Bridges and F.~Richman.
\newblock \emph{Varieties of Constructive Mathematics}.
\newblock Cambridge University Press, 1987.

\bibitem{LeanProver}
The Lean 4 theorem prover.
\newblock \url{https://leanprover.github.io/}

\bibitem{mathlib}
The mathlib4 mathematical library.
\newblock \url{https://github.com/leanprover-community/mathlib4}

\end{thebibliography}

% ===========================================================
% APPENDICES
% ===========================================================

\appendix

\section{Lean Implementation Snippets}

\subsection{The main equivalence (top level)}

\begin{lstlisting}[caption={Complete bidirectional proof (top level)}]
/-- The main equivalence theorem -/
theorem gap_equiv_wlpo : BidualGapStrong.{0} ↔ WLPO := by
  constructor
  · -- Gap implies WLPO
    intro h_gap
    classical
    exact kernel_implies_wlpo (construct_kernel h_gap)
  · -- WLPO implies Gap (witness: c₀)
    intro hwlpo
    exact construct_gap_from_wlpo hwlpo
\end{lstlisting}

\subsection{Robust csSup proof}\label{app:csSup-proof}

\begin{lstlisting}[caption={csSup of partial sums equals the tsum (nonnegative case)}]
private lemma tsum_eq_csSup_sum_of_nonneg
  {ι : Type*} (u : ι → ℝ) (h0 : ∀ i, 0 ≤ u i) (hs : Summable u) :
  (∑' i, u i) = sSup (Set.range (fun s : Finset ι => ∑ i ∈ s, u i)) := by
  have nonempty : (Set.range _).Nonempty := ⟨0, ∅, by simp⟩
  have bdd : BddAbove (Set.range _) := by
    use ∑' i, u i
    rintro x ⟨s, rfl⟩
    exact sum_le_tsum s (fun i _ => h0 i) hs
  apply le_antisymm
  · apply tsum_le_of_sum_le hs; intro s; exact le_csSup bdd ⟨s, rfl⟩
  · apply csSup_le nonempty; rintro x ⟨s, rfl⟩
    exact sum_le_tsum s (fun i _ => h0 i) hs
\end{lstlisting}

\subsection{Stone window core}\label{app:stone-window}

\begin{lstlisting}[caption={Core sketches for Stone window}]
/-- Boolean algebra at infinity -/
def BooleanAtInfinity := Quotient (Set ℕ) FinSymmDiff

/-- Sequences modulo c₀ -/
def SeqModC0 := Quotient (ℕ → ℝ) EqModC0

/-- The Stone window map -/
def iotaBar : BooleanAtInfinity → SeqModC0 :=
  Quotient.lift (fun A => ⟦χ A⟧) χ_respects_fin

theorem iotaBar_injective : Function.Injective iotaBar := by
  intros ⟨A⟩ ⟨B⟩ h
  have : χ A - χ B ∈ c₀ := quotient_eq_implies_diff_in_c0 h
  exact finite_symmDiff_of_indicator_in_c0 this
\end{lstlisting}

\section{Reverse Direction Details}

\begin{lstlisting}[caption={Lemma structure for WLPO ⇒ Gap}]
/-- WLPO gives a Prop-level separator for the encodings used (c₀ version). -/
lemma wlpo_gives_prop_separator [HasWLPO] (v : c₀) :
  (⟦v⟧ = (0 : c₀/ker)) ∨ (⟦v⟧ ≠ 0) := by
  -- use HasWLPO.wlpo on a derived binary sequence
  ...

/-- Construct the bidual functional G on (c₀)* via G(f) = Σ f(eₙ). -/
lemma construct_bidual_functional [HasWLPO] :
  ∃ G : (c₀)**, G ≠ 0 ∧ G ∉ canonicalEmbedding.range := by
  -- Use the fact that (c₀)* ≅ ℓ¹ to define G(f) = Σ f(eₙ)
  ...

/-- Main construction: WLPO implies gap for c₀. -/
lemma wlpo_implies_gap_c0 [HasWLPO] :
  ∃ G : (c₀)**, G ∉ canonicalEmbedding.range := by
  exact construct_bidual_functional
\end{lstlisting}

\section{Computational Code}\label{app:computational}

\begin{lstlisting}[language=Python, caption={Finite Hahn--Banach verification (Cesàro means)}]
import random
from typing import Callable, List

def cesaro_mean_functional(n: int) -> Callable:
    """Create the Cesàro mean functional for R^n."""
    def f_n(x: List[float]) -> float:
        return sum(x) / n
    return f_n

def verify_finite_hahn_banach(n: int, tolerance: float = 1e-10):
    """Verify finite-dimensional Hahn-Banach properties."""
    f = cesaro_mean_functional(n)

    # Vanishes on {x : sum(x) = 0}
    for _ in range(100):
        x = [random.gauss(0, 1) for _ in range(n-1)]
        x.append(-sum(x))
        assert abs(f(x)) < tolerance

    # f(1,...,1) = 1
    ones = [1] * n
    assert abs(f(ones) - 1) < tolerance

    # ||f|| = 1 on the sup-norm unit ball
    for _ in range(1000):
        x = [random.uniform(-1, 1) for _ in range(n)]
        assert abs(f(x)) <= 1 + tolerance

    return True

if __name__ == "__main__":
    print("=== Verification Started ===")
    for n in [2, 10, 50]:
        verify_finite_hahn_banach(n)
        print(f"Verified n={n}")
    print("=== All Tests Passed ===")
\end{lstlisting}

\end{document}