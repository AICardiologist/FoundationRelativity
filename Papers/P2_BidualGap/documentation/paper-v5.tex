
\documentclass[11pt]{article}

% ------------------------------------------------------------
% Standard LaTeX packages
% ------------------------------------------------------------
\usepackage[margin=1in]{geometry}
\usepackage{lmodern}
\usepackage{amsmath,amssymb,mathtools}
\usepackage[american]{babel}
\usepackage{stmaryrd}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning,cd}
\usepackage{listings}
\usepackage[x11names,table]{xcolor}
\usepackage{graphicx}
\usepackage{array}
\usepackage{mdframed}
\usepackage{url}
% hyperref should typically come last
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}

% Define theorem-like environments
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
% Alias used in body:
\newenvironment{defi}{\begin{definition}}{\end{definition}}

% ---------- Lean repo link ----------
\newcommand{\leanRepo}{\url{https://github.com/AICardiologist/FoundationRelativity}}
\newcommand{\leanok}{\textsf{\small \textcolor{green!70!black}{✓}}}
\newcommand{\leanpartial}{\textsf{\small \textcolor{orange!80!black}{◐}}}

% ---------- Mathematical notation ----------
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\linf}{\ell^\infty}
\newcommand{\cnull}{c_0}
\newcommand{\WLPO}{\mathrm{WLPO}}
\newcommand{\BISH}{\mathrm{BISH}}
\newcommand{\CRM}{\mathrm{CRM}}
\newcommand{\LEM}{\mathrm{LEM}}
\newcommand{\DC}{\mathrm{DC}}
\newcommand{\ZFC}{\mathrm{ZFC}}

% ---------- Code listing style for Lean ----------
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{Lean}{
  keywords={theorem, lemma, def, definition, axiom, structure, class, instance, 
            by, exact, intro, intros, apply, refine, constructor, use, obtain, 
            have, show, from, fun, assume, let, in, if, then, else,
            match, with, end, namespace, section, variable, variables,
            example, begin, sorry, admit, noncomputable, classical,
            import, open, export, private, protected, mutual, meta,
            do, for, while, return, try, catch, finally,
            Type, Prop, Sort, Type*, forall, exists, where, extends},
  sensitive=true,
  morecomment=[l]{--},
  morecomment=[s]{/-}{-/},
  morestring=[b]",
  literate=
    {α}{{$\alpha$}}1 {β}{{$\beta$}}1 {γ}{{$\gamma$}}1
    {δ}{{$\delta$}}1 {ε}{{$\varepsilon$}}1 {ζ}{{$\zeta$}}1
    {η}{{$\eta$}}1 {θ}{{$\theta$}}1 {ι}{{$\iota$}}1
    {κ}{{$\kappa$}}1 {λ}{{$\lambda$}}1 {μ}{{$\mu$}}1
    {ν}{{$\nu$}}1 {ξ}{{$\xi$}}1 {π}{{$\pi$}}1
    {ρ}{{$\rho$}}1 {σ}{{$\sigma$}}1 {τ}{{$\tau$}}1
    {φ}{{$\varphi$}}1 {χ}{{$\chi$}}1 {ψ}{{$\psi$}}1
    {ω}{{$\omega$}}1 {Γ}{{$\Gamma$}}1 {Δ}{{$\Delta$}}1
    {Θ}{{$\Theta$}}1 {Λ}{{$\Lambda$}}1 {Σ}{{$\Sigma$}}1
    {Φ}{{$\Phi$}}1 {Ψ}{{$\Psi$}}1 {Ω}{{$\Omega$}}1
    {→}{{$\rightarrow$}}1 {←}{{$\leftarrow$}}1 {↔}{{$\leftrightarrow$}}1
    {∀}{{$\forall$}}1 {∃}{{$\exists$}}1 {∈}{{$\in$}}1
    {∉}{{$\notin$}}1 {⊆}{{$\subseteq$}}1 {⊂}{{$\subset$}}1
    {∪}{{$\cup$}}1 {∩}{{$\cap$}}1 {≤}{{$\leq$}}1
    {≥}{{$\geq$}}1 {≠}{{$\neq$}}1 {≈}{{$\approx$}}1
    {≡}{{$\equiv$}}1 {∧}{{$\land$}}1 {∨}{{$\lor$}}1
    {¬}{{$\neg$}}1 {ℕ}{{$\mathbb{N}$}}1 {ℝ}{{$\mathbb{R}$}}1
    {ℂ}{{$\mathbb{C}$}}1 {ℤ}{{$\mathbb{Z}$}}1
    {·}{{$\cdot$}}1 {∑}{{$\sum$}}1 {∏}{{$\prod$}}1
    {∅}{{$\emptyset$}}1 {∞}{{$\infty$}}1 {∂}{{$\partial$}}1
}

\lstdefinestyle{leanstyle}{
    language=Lean,
    backgroundcolor=\color{backcolour},    
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    numberstyle=\tiny\color{codegray}
}

\lstset{style=leanstyle}

% ---------- Title and author ----------
\title{The Bidual Gap and WLPO: A Constructive Calibration of Banach Space Non-Reflexivity}
\author{Paul Chun-Kit Lee\thanks{AI disclosure:
This Lean 4 formalization was produced by multi-AI agents (GPT-5 Pro, Gemini, Claude) working under human direction. All proofs, definitions, and mathematical structures in the repository were AI-generated as part of an experiment in AI-assisted formal mathematics. The author provided project direction, mathematical goals, and verification. All content has been machine-checked by Lean~4. The author takes full responsibility for the mathematical correctness and presentation.}\thanks{Lean 4 formalization available at \leanRepo. Code archive: DOI \texttt{10.5281/zenodo.17107493}.} \\ 
New York University \\ 
\texttt{dr.paul.c.lee@gmail.com}}
\date{\today}

\begin{document}

\begin{abstract}
Over Bishop-style constructive mathematics (\BISH), we identify the exact logical strength of a familiar non-reflexivity phenomenon in Banach space theory. Working in a classical meta-theory, we prove that the following are equivalent over \BISH: the Weak Limited Principle of Omniscience (\WLPO); the non-surjectivity of the canonical embedding $J_{\ell^\infty}:\ell^\infty\to(\ell^\infty)^{**}$; and the existence of a real Banach space with a bidual gap. 

This equivalence builds on and refines earlier connections between variants of Hahn--Banach and omniscience principles in constructive reverse mathematics (e.g.\ work of Ishihara; Bridges--Richman; and surveys such as Diener) by isolating the \emph{bare bidual-gap statement} and locating it precisely at \WLPO. Our Lean~4 development separates the (meta-classical) witness-extraction step from the (constructive) analysis that derives \WLPO from an abstract kernel, making the logical hygiene explicit. We also include a constructively careful account of the Boolean algebra of idempotents in $\ell^\infty/c_0$ (a ``Stone window'') and finite-dimensional surrogates via Ces\`{a}ro means. 

We view the contribution as modest but useful: to place a classically standard fact at an exact level in \CRM, and to provide a machine-checked record that may serve future calibrations.
\end{abstract}

\maketitle

\begin{mdframed}[backgroundcolor=gray!08, linewidth=0.4pt]
\noindent\textbf{AI-Generated Formalization Disclosure.}
This entire Lean 4 formalization project was produced by multi-AI agents working under human direction. All proofs, definitions, and mathematical structures in this repository were AI-generated. This represents a case study in using multi-AI agent systems to tackle complex formal mathematics problems with human guidance on project direction. The mathematical content has been verified through Lean's proof checker. Users should be aware that the code was AI-generated as part of an experiment in AI-assisted formal mathematics. The author provided the mathematical goals, project direction, and verification oversight, and takes full responsibility for the content.
\end{mdframed}

\tableofcontents

% ===========================================================
\section{Introduction: Non-reflexivity, Constructivity, and Logical Strength}
% ===========================================================

For a Banach space $X$, the canonical embedding $J_X:X\to X^{**}$ maps $x$ to evaluation at $x$. Classically, many spaces fail to be reflexive (i.e.\ $J_X$ is not surjective); for example, $\ell^\infty$ is non-reflexive via Hahn--Banach. In Bishop-style constructive mathematics (\BISH), however, the status of such facts can depend on additional logical principles. It is therefore natural, in the spirit of constructive reverse mathematics (\CRM), to ask for the \emph{precise} logical strength of non-reflexivity statements over \BISH. We emphasize that nothing here alters the classical status of these results; the point is to describe their exact logical strength \emph{over \BISH} and to record clean proofs with explicit axiom boundaries.

Building on prior work that relates forms of Hahn--Banach to omniscience principles (notably Ishihara's calibration results and subsequent surveys), we prove that, over \BISH, the following are equivalent: \WLPO; non-surjectivity of $J_{\ell^\infty}$; and the existence of a real Banach space with a bidual gap. Our aim is modest: to make explicit, and to formalize in Lean~4, a calibration that we have not found written down in this exact form, and to present it with careful separation between meta-classical witness extraction and constructive analysis.

\begin{definition}[Non-reflexivity and bidual gap]
A Banach space $X$ is \textbf{non-reflexive} if the canonical embedding $J_X$ is not surjective. In this case, we say $X$ \textbf{has a bidual gap}.
\end{definition}

\subsection{Related work and positioning}

This paper fits into a line of results locating analytic theorems over \BISH\ at specific logical principles.

\begin{itemize}[leftmargin=2em]
\item \textbf{Hahn--Banach and omniscience.} Ishihara~\cite{Ishihara90,Ishihara06} and others isolated forms of Hahn--Banach that imply or are equivalent to weak omniscience principles such as \WLPO. Bridges and Richman~\cite{Bridges87} present the broader constructive context; Diener~\cite{DienerCRM} surveys \CRM\ calibrations.

\item \textbf{Classical reverse mathematics.} Brown--Simpson~\cite{BrownSimpson86} analyzed set-existence strength behind analytic theorems in the classical base theory. Our use of a two-stage argument (meta extraction, internal analysis) mirrors that methodology in a constructive setting.

\item \textbf{Non-reflexivity folklore.} That $\ell^\infty$ is non-reflexive is a textbook fact (e.g.\ \cite{ConwayFA,Megginson98,AlbiacKalton16}). The \emph{logical} content of the \emph{bare non-reflexivity statement} over \BISH\ appears not to have been recorded explicitly; our contribution is to formulate and verify the bi-implication with \WLPO. To our knowledge, the equivalence between the bare non-reflexivity statements (for $\ell^\infty$ and ``$\exists X$'') and \WLPO over \BISH\ has not been recorded explicitly; we regard the present contribution as making that calibration precise and verifiable.
\end{itemize}

Compared with the literature above, our novelty lies in identifying the exact logical strength of \emph{non-surjectivity of $J_{\ell^\infty}$ and the existence of a bidual gap} (rather than particular extension/separation schemes) exactly at \WLPO, and in making the meta-classical/constructive separation explicit and machine-checked.

\subsection{The Weak Limited Principle of Omniscience (WLPO)}

\begin{defi}[$\WLPO$]
For any binary sequence $\alpha:\N\to\{0,1\}$,
\[
(\forall n,\ \alpha(n)=0)\ \ \vee\ \ \neg(\forall n,\ \alpha(n)=0).
\]
\end{defi}

$\WLPO$ is strictly weaker than $\LEM$ but not provable in $\BISH$. It captures the minimal decision strength needed to determine whether an infinite sequence is identically zero.

\subsection{Main result and contributions}

\begin{thm}[Main Theorem]
Over $\BISH$, the following are equivalent:
\begin{enumerate}
\item $\WLPO$.
\item \textbf{Gap$_{\linf}$:} The embedding $J_{\linf}:\linf\to(\linf)^{**}$ is not surjective.
\item \textbf{Gap$_{\exists}$:} There exists a real Banach space $X$ such that $J_X:X\to X^{**}$ is not surjective.
\end{enumerate}
Moreover, this equivalence is fully formalized in Lean~4 (see Section~\ref{sec:lean}).
\end{thm}

\noindent\emph{Scope.} Throughout, ``over \BISH'' means that the implication is derivable in \BISH; the meta-proof certifying the derivation may use classical reasoning (see Remark~\ref{rem:meta-classical}).

Our contributions are:
\begin{enumerate}[label=\arabic*.]
\item \textbf{Exact location over \BISH.} Building on Ishihara's connections between Hahn--Banach and omniscience principles, we show that the \emph{bare bidual-gap statements} (for $\ell^\infty$ and $\exists X$) are each equivalent to \WLPO.
\item \textbf{Formal verification.} A Lean~4 development makes explicit the separation between meta-classical extraction and constructive analysis, and provides an axiom audit for the consumer lemma.
\item \textbf{Auxiliary tools.} We package a Prop-level kernel interface, a csSup treatment of partial sums suited to \BISH, and a constructively careful ``Stone window'' for $\ell^\infty/c_0$ used as a tool rather than a headline result.
\end{enumerate}

% ===========================================================
\section{Main Mathematical Results: The Equivalence Theorem}
% ===========================================================

We explain the equivalence between the bidual gap and $\WLPO$.

\subsection{Forward direction: Gap implies WLPO}

To bridge a bidual-gap witness and a logical decision, we use an ``Ishihara kernel'', adapted from constructive reverse mathematics.

\begin{defi}[Ishihara kernel]
An \emph{Ishihara kernel} is a specific \emph{CRM witness/test object} with a sharp
dichotomy, designed so that purely constructive analysis of its properties decides $\WLPO$.
It consists of a normed space $X$, an element $y\in X^{**}\setminus J(X)$, a functional $f\in X^*$, a family $g:(\N\to\{0,1\})\to X^*$, and a constant $\delta>0$ such that for all binary sequences $\alpha$:
\begin{enumerate}
\item $|y(f+g(\alpha))|=0$ or $|y(f+g(\alpha))|\ge \delta$ (dichotomy);
\item $(\forall n,\ \alpha(n)=0)\ \Leftrightarrow\ y(f+g(\alpha))=0$ (decision property).
\end{enumerate}
\end{defi}

\begin{lem}[Kernel $\Rightarrow$ $\WLPO$]
If an Ishihara kernel exists, then $\WLPO$ holds.
\end{lem}

\begin{proof}
Given $\alpha$, compute $s=|y(f+g(\alpha))|$. By dichotomy, either $s=0$ or $s\ge \delta>0$. The decision property equates $s=0$ with $(\forall n,\alpha(n)=0)$, deciding the $\WLPO$ instance.
\end{proof}

\begin{thm}[Gap implies $\WLPO$ (meta-classical)]\label{thm:gap-implies-wlpo}
Working in a classical meta-theory: if some Banach space $X$ has $J:X\to X^{**}$ not surjective, 
then $\WLPO$ holds over $\BISH$.
\end{thm}

\begin{proof}
Choose $y\in X^{**}\setminus J(X)$ with $y\ne 0$. A half-norm attainment lemma yields $h\in X^*$ with $\|h\|\le 1$ and $|y(h)|>\|y\|/2$. Let $f=0$, $\delta=|y(h)|/2$ (so $\delta>0$ by $0 \leq \|y\|/2 < |y(h)|$), and
\[
g(\alpha)=\begin{cases}
0 & \text{if } \forall n,\alpha(n)=0,\\
h & \text{otherwise}.
\end{cases}
\]
Then the dichotomy and decision properties hold, so the kernel exists.
\end{proof}

\subsection{Foundation-theoretic interlude: Classical logic in reverse mathematics}

Before proceeding to the reverse direction, we must address a subtle but crucial point about the use of classical logic in constructive reverse mathematics.

\begin{rem}[Classical meta-logic vs. object logic]\label{rem:meta-classical}
The definition of $g(\alpha)$ in the proof case-splits on the undecidable proposition
$(\forall n,\alpha(n)=0)$. In $\BISH$, we cannot constructively perform this case split.
However, in reverse mathematics, we work in a \emph{classical meta-logic} to prove
statements \emph{about} $\BISH$.

Concretely, we prove the implication:
\[
  \text{(classically)}\quad
  \big[\text{there exists a Banach space with a bidual gap (a $\BISH$-provable statement)}\big]
  \;\Longrightarrow\;
  \big[\BISH \vdash \WLPO\big].
\]
This is the standard proof strategy in Constructive Reverse Mathematics (CRM), which follows a two-part structure: \emph{meta-classical witness extraction} followed by \emph{constructive analysis of the witness}. First, operating in a meta-theory, we use non-constructive reasoning to extract a concrete witness---in our case, an Ishihara kernel---from a classical theorem. Second, we analyze this witness using only the logic of the constructive base theory ($\BISH$) to derive a non-constructive principle like $\WLPO$.

In the formalization, we fence the meta-classical reasoning (witness extraction and
the case split in $g$) inside a dedicated block, and keep the kernel analysis
(\emph{Ishihara kernel} $\Rightarrow \WLPO$) intuitionistic. No classical axiom
is added to the object theory. This approach follows Ishihara's original pattern for extracting logical principles from functional analysis results \cite{Ishihara90}.
\end{rem}

\begin{rem}[Terminology: \emph{witness/test object} in CRM]
In constructive reverse mathematics (CRM), the standard phrasing for the two-stage pattern used here is:
\emph{(meta-classical) witness extraction} followed by \emph{(constructive) analysis of the witness}.
The specific witness we use is an \emph{Ishihara-style} test object with a sharp dichotomy
$|y(f+g(\alpha))|=0 \;\vee\; |y(f+g(\alpha))|\ge \delta$; this is a well-known pattern for calibrating results at
$\WLPO$ (see Ishihara~\cite{Ishihara90} and the survey~\cite{DienerCRM}).%
\footnote{In an earlier draft we informally called this a ``producer/consumer'' split. We keep that
metaphor out of the formal presentation and use the standard CRM terms \emph{witness extraction} and
\emph{constructive analysis}.}
A closely related separation of concerns is common in classical reverse mathematics, e.g.\ the work of
Brown--Simpson~\cite{BrownSimpson86} on the set-existence strength behind analytic theorems.
\end{rem}

\paragraph{Special note (differences from an earlier draft).}
Two technical changes make the argument robust and CRM-compliant:
\begin{enumerate}
  \item \textbf{Gap parameter.} We set
  \[
    \delta \;:=\; \frac{|y(h^\star)|}{2}\,,
  \]
  where $h^\star\in X^\ast$ satisfies $\|h^\star\|\le 1$ and
  $\tfrac{\|y\|}{2}<|y(h^\star)|$. This yields $\delta>0$ by elementary
  order facts ($0\le \tfrac{\|y\|}{2} < |y(h^\star)|$ implies $0<|y(h^\star)|$,
  hence $0<\delta$). In particular, we do \emph{not} need to derive $\|y\|>0$
  from $y\neq 0$, which would otherwise force norm-positivity lemmas at the bidual
  type and introduce foundational friction in a constructive setting.
  \item \textbf{Fencing classical reasoning.} The only classical steps are:
  picking $y\in X^{**}\!\setminus j(X)$, obtaining $h^\star$, and
  defining $g(\alpha)$ by a global case split. The kernel consumer
  (from the separation statement and the zero-characterization to $\WLPO$)
  is intuitionistic and does not depend on classical principles.
\end{enumerate}
Both changes are invisible at the level of classical mathematics, but they are
important for constructive reverse mathematics: the consumer no longer relies on
bidual-specific norm facts or undecidable case splits.

\subsection{Reverse direction: WLPO implies gap}

\begin{thm}[$\WLPO$ implies Gap]
If $\WLPO$ holds, then $J:\linf\to(\linf)^{**}$ is not surjective.
\end{thm}

\begin{proof}[Proof sketch]
We reduce a generic instance of $\WLPO$ to separation in $\ell^\infty/c_0$ by a
uniform \emph{coding} of binary sequences. Given $\alpha\in\{0,1\}^{\mathbb N}$,
define a bounded sequence $v^\alpha$ whose membership in $c_0$ is equivalent to
$(\forall n,\alpha(n)=0)$ (e.g.\ by sparse ``pulses'' placed far apart, or via a
bounded alternating prefix with a single switch triggered by the first $1$).
Then $\WLPO$ decides whether $v^\alpha\in c_0$. Using these codes one constructs
an $\mathbb R$-linear functional $\Phi:\ell^\infty\to\mathbb R$ with $\Phi|_{c_0}=0$
and $\Phi(v^\alpha)\neq 0$ for some $\alpha$. The induced functional on the
quotient $\ell^\infty/c_0$ yields $G\in(\ell^\infty)^{**}$ with
$G\not\in J_{\ell^\infty}(\ell^\infty)$, giving the bidual gap.
\end{proof}

\subsection{A structural byproduct}

\begin{thm}[Gap structure]
Assuming $\WLPO$, the quotient $\linf/\cnull$ is nontrivial and carries a Boolean algebra of idempotents with rich structure.
\end{thm}

This connects naturally with the ``Stone window'' theorem in Section~\ref{sec:stone}.

% ===========================================================
\section{Constructive Algorithms: Finite Approximations}
% ===========================================================

Finite-dimensional surrogates clarify the constructive boundary: they are computable and illuminating, but their infinite limit would decide $\WLPO$-type predicates.

\subsection{Ces\`aro mean surrogates}

\begin{defi}[Ces\`aro mean]
For $n\ge 1$, define $f_n:\R^n\to\R$ by $f_n(x)=\frac{1}{n}\sum_{i=1}^n x_i$.
\end{defi}

\begin{thm}[Constructive finite Hahn--Banach]\label{thm:finite-hb}\leanok
With the sup norm on $\R^n$, the average $f_n(x)=\frac{1}{n}\sum_{i=1}^n x_i$ is the unique linear functional of norm $1$ satisfying $f_n(1,\dots,1)=1$ and $\ker(f_n)=M_n:=\{x\in\R^n:\sum_{i=1}^n x_i=0\}$.
\end{thm}

\begin{proof}
If $\|x\|_\infty\le 1$, then $|f_n(x)|\le \frac{1}{n}\sum_{i=1}^n|x_i|\le 1$, with equality at $x=(1,\dots,1)$, so $\|f_n\|=1$. The kernel claim is immediate from linearity and the definition of $M_n$; uniqueness follows because any linear functional with this kernel and value on $(1,\dots,1)$ must agree with $f_n$ on a direct-sum decomposition $\R^n=M_n\oplus \mathrm{span}\{(1,\dots,1)\}$.
\end{proof}

\subsection{Computational implementation}

We provide $O(n)$ implementations (see the repository) to verify Theorem~\ref{thm:finite-hb} numerically.

\subsection{Convergence and the constructive boundary}

\begin{thm}[Non-constructive limit]
Viewing $(f_n)$ as functionals on $\linf$ via projection, any constructive pointwise limit that separates the encodings described below would decide a $\WLPO$-level predicate, and hence does not exist in $\BISH$.
\end{thm}

\begin{proof}[Proof sketch]
Encode a $\WLPO$ instance $\alpha$ by $v^\alpha\in\linf$; in a simple restricted case (at most one $1$) let $v^\alpha_n=(-1)^{\sum_{k\le n}\alpha_k}$. Then $f_n(v^\alpha)$ converges to different limits depending on whether $\alpha$ is all zeros or has a single $1$. A constructive limit would decide that dichotomy.
\end{proof}

% ===========================================================
\section{Formalization in Lean 4}\label{sec:lean}
% ===========================================================

\subsection{Overview and axiom profile}\label{sec:axioms}

Our Lean 4 formalization contains about 4{,}500 lines of verified code.
\begin{itemize}
\item \textbf{Bidirectional proof:} both Gap $\Rightarrow$ $\WLPO$ and $\WLPO$ $\Rightarrow$ Gap.
\item \textbf{Auxiliaries:} near-constructive development of $(\cnull)^*\cong \ell^1$ and the Stone window.
\item \textbf{Axioms:}
\begin{lstlisting}[language=Lean,numbers=none]
#print axioms gap_equiv_wlpo
-- [propext, Classical.choice, Quot.sound]
\end{lstlisting}
Here, \texttt{Quot.sound} underlies quotients like $\linf/\cnull$; \texttt{propext} is used extensively at Prop level; and \texttt{Classical.choice} (with \texttt{open Classical}) provides classical case splits in the meta-logic, as discussed in Remark~\ref{rem:meta-classical}.
\end{itemize}

\subsection{CRM methodology and axiom hygiene}\label{sec:crm-hygiene}

Following standard CRM (Constructive Reverse Mathematics) methodology, our formalization 
separates the \emph{classical producer} from the \emph{constructive consumer}:

\begin{itemize}
\item \textbf{Meta-classical witness extraction:} The construction of the Ishihara kernel from the bidual gap,
  including extraction of $y \in X^{**} \setminus J(X)$, finding $h^\star$ with $\|y\|/2 < \|y(h^\star)\|$,
  and defining $g(\alpha)$ via case-splitting on the undecidable predicate $(\forall n, \alpha(n) = 0)$.
  This is fenced in \texttt{section ClassicalMeta} in \texttt{Ishihara.lean}.

\item \textbf{Constructive analysis of the witness:} The theorem \texttt{WLPO\_of\_kernel} that derives $\WLPO$ 
  from the abstract kernel properties. This is placed \emph{outside} any \texttt{noncomputable} or 
  \texttt{Classical} sections, ensuring pure intuitionistic reasoning.
\end{itemize}

This separation can be mechanically verified in Lean:
\begin{lstlisting}[language=Lean,numbers=none]
#print axioms WLPO_of_kernel
-- (no classical axioms)

#print axioms WLPO_of_gap  
-- [propext, Classical.choice, Quot.sound]
\end{lstlisting}

The result properly demonstrates that in a classical meta-theory, 
$\textsf{BISH} \vdash \textsf{BidualGapStrong} \Rightarrow \WLPO$.

This mechanical separation is not mathematically deep, but it reduces the risk of inadvertently importing classical reasoning into the constructive core.

\subsection{Reproducibility information}

\begin{mdframed}[backgroundcolor=gray!10]
\textbf{Reproducibility Box}
\begin{itemize}
\item \textbf{Repository}: \leanRepo
\item \textbf{Lean toolchain}: \texttt{leanprover/lean4:v4.22.0-rc4}
\item \textbf{mathlib4 commit}: \texttt{59e4fba0c656457728c559a7d280903732a6d9d1}
\item \textbf{Project tag}: \texttt{p2-crm-v0.2} / commit \texttt{85f69aa}
\item \textbf{Build}: \texttt{lake exe cache get \&\& lake build} \\
      top-level target: \texttt{Papers.P2\_BidualGap.gap\_equiv\_wlpo}
\item \textbf{Code Archive DOI}: \texttt{10.5281/zenodo.17107493}
\item \textbf{Status}: The main equivalence builds with 0 errors. Three WLPO-conditional lemmas remain in the optional module \texttt{DualIsometriesComplete.lean} concerning completeness of certain dual spaces; they do not affect the main equivalence.
\item \textbf{AI Generation}: See the front-page disclosure regarding the AI-generated nature of this formalization.
\end{itemize}
\end{mdframed}

\subsection{Key technical solutions}

\paragraph{Prop-level kernel technique.}
We implement the Ishihara kernel entirely at Prop level.

\begin{lstlisting}[caption={Ishihara kernel (illustrative Lean snippet)}]
structure IshiharaKernel where
  -- fields omitted
  kernel_property : ∀ α, |y (f + g α)| = 0 ∨ δ ≤ |y (f + g α)|
  decision_property : ∀ α, (∀ n, α n = false) ↔ y (f + g α) = 0

lemma WLPO_of_kernel (K : IshiharaKernel) : WLPO := by
  intro α
  cases K.kernel_property α with
  | inl h => left; exact (K.decision_property α).mpr h
  | inr h => right; exact mt (K.decision_property α).mp (ne_of_gt h)
\end{lstlisting}

\paragraph{Robust csSup for partial sums.}
We avoid fragile complete-lattice instance resolution by working directly with conditional suprema:
\begin{lstlisting}[caption={tsum equals csSup of finite partial sums}]
private lemma tsum_eq_csSup_sum_of_nonneg
  {ι : Type*} (u : ι → ℝ) (h0 : ∀ i, 0 ≤ u i) (hs : Summable u) :
  (∑' i, u i) = sSup (Set.range (fun s : Finset ι => ∑ i ∈ s, u i)) := by
  have nonempty : (Set.range _).Nonempty := ⟨0, ∅, by simp⟩
  have bdd : BddAbove (Set.range _) := by
    use ∑' i, u i
    rintro x ⟨s, rfl⟩
    exact sum_le_tsum s (fun i _ => h0 i) hs
  apply le_antisymm
  · apply tsum_le_of_sum_le hs; intro s; exact le_csSup bdd ⟨s, rfl⟩
  · apply csSup_le nonempty; rintro x ⟨s, rfl⟩
    exact sum_le_tsum s (fun i _ => h0 i) hs
\end{lstlisting}

\paragraph{HasWLPO architecture.}
A lightweight typeclass separates WLPO-dependent arguments from constructive cores.

\begin{lstlisting}[caption={WLPO typeclass sketch}]
class HasWLPO : Prop :=
  (wlpo : ∀ (α : ℕ → Bool), (∀ n, α n = false) ∨ ¬(∀ n, α n = false))

lemma gap_exists_of_WLPO [HasWLPO] : ...
instance [Classical] : HasWLPO := ⟨fun α => em _⟩
\end{lstlisting}

\subsection{The bidirectional theorem (Lean)}

\begin{lstlisting}[caption={WLPO ↔ Gap (top-level equivalence)}]
theorem gap_equiv_wlpo : BidualGapStrong.{0} ↔ WLPO := by
  constructor
  · intro h_gap
    classical
    -- construct kernel from gap witness and apply WLPO_of_kernel
    exact WLPO_of_kernel (kernel_from_gap h_gap)
  · intro hwlpo
    -- construct gap from HasWLPO instance
    exact gap_from_WLPO hwlpo
\end{lstlisting}

% ===========================================================
\section{Stone Window: The Boolean Algebra Connection}\label{sec:stone}
% ===========================================================

We relate logic and analysis via a concrete Boolean algebra in the quotient.

\subsection{Almost-equality and idempotents}

\begin{defi}[Almost equality]
For $A,B\subseteq\N$, write $A\sim B$ if the symmetric difference $A\triangle B$ is finite.
\end{defi}

\begin{defi}
Write $\mathrm{Idem}(B)$ for the set of idempotents of a (commutative) Banach algebra $B$ under the induced Boolean operations $e\wedge f:=ef$, $e\vee f:=e+f-ef$, and $\neg e:=1-e$.
\end{defi}

\begin{thm}[Stone window]\label{thm:stone}\leanok
Equip $\ell^\infty/c_0$ with the quotient Banach algebra structure induced by pointwise operations. The map
$\Phi:\mathcal{P}(\N)/{\sim}\to \mathrm{Idem}(\linf/\cnull)$,
$[A]\mapsto [\chi_A]$, is a Boolean algebra isomorphism.
\end{thm}

\begin{proof}[Proof sketch]
(1) $[\chi_A]=[\chi_B]$ iff $\chi_A-\chi_B\in \cnull$, i.e.\ $A\sim B$.  
(2) Boolean operations are respected.  
(3) Every idempotent is equivalent (mod $\cnull$) to an indicator via thresholding at $1/2$.
\end{proof}

\begin{cor}[Finite distributive lattices]\leanok
Every finite distributive lattice embeds into $\mathrm{Idem}(\linf/\cnull)$.
\end{cor}

% ===========================================================
\section{Significance and Conclusion}
% ===========================================================

\subsection{Precise logical calibration}

The result places a familiar analytic phenomenon exactly at $\WLPO$, demonstrating how constructive reverse mathematics can sharpen vague ``non-constructive'' labels into precise equivalences.

\subsection{Foundation relativity}

\begin{center}
\small % Make text smaller instead of resizing
\begin{tabular}{lll}
\toprule
Foundation & Statement about the gap ($\exists y\notin \mathrm{im}(J)$) & Comment \\
\midrule
$\ZFC$ & \emph{Holds} & Hahn--Banach yields witnesses \\
$\BISH$ & \emph{Equivalent to $\WLPO$} & (Main Theorem) \\
$\BISH+\DC$ & \emph{Equivalent to $\WLPO$} & $\DC$ does not imply $\WLPO$ \\
$\BISH+\WLPO$ & \emph{Holds} & by equivalence \\
$\BISH+\neg\WLPO$ & \emph{Not provable} & fails in models of $\BISH+\neg\WLPO$ \\
\bottomrule
\end{tabular}
\end{center}

\subsection{The role of formalization}

The Lean development clarified axiom usage, suggested robust approaches to conditional suprema, and yielded reusable patterns (Ishihara kernel, HasWLPO) for future formalized reverse mathematics.

\subsection{Conclusion}

We establish and formalize that detecting the bidual gap has exactly the logical strength of $\WLPO$ over $\BISH$. Finite constructive surrogates illuminate the obstruction at the infinite limit. The approach integrates constructive analysis, reverse mathematics, and mechanized verification. We do not address stronger choice principles, nor do we attempt to calibrate other classical non-reflexivity phenomena; our focus here is solely the bidual-gap statements above.

\section*{Acknowledgments}

We are indebted to the constructive analysis and reverse mathematics communities for the conceptual groundwork: in particular E.~Bishop, D.~S.~Bridges, F.~Richman, and H.~Ishihara, and to surveys such as Diener's overview of constructive reverse mathematics. Discussions in the Lean and mathlib communities shaped the formalization style. Any remaining mistakes are the author's alone.

\smallskip
\noindent\textbf{AI note.} The Lean formalization was AI-generated; see the front-page disclosure for details. All results have been machine-checked in Lean~4.

\bibliographystyle{alphaurl}
\begin{thebibliography}{10}

\bibitem{Bishop67}
E.~Bishop.
\newblock \emph{Foundations of Constructive Analysis}.
\newblock McGraw-Hill, 1967.

\bibitem{Ishihara06}
H.~Ishihara.
\newblock Reverse mathematics in Bishop's constructive mathematics.
\newblock \emph{Philosophia Scientiae}, Cahier Sp\'ecial 6:43--59, 2006.

\bibitem{AlbiacKalton16}
F.~Albiac and N.~J. Kalton.
\newblock \emph{Topics in Banach Space Theory}.
\newblock Springer, 2nd edition, 2016.

\bibitem{Bridges87}
D.~S. Bridges and F.~Richman.
\newblock \emph{Varieties of Constructive Mathematics}.
\newblock Cambridge University Press, 1987.

\bibitem{BrownSimpson86}
D.~K. Brown and S.~G. Simpson.
\newblock Which set existence axioms are needed to prove the separable Hahn--Banach theorem?
\newblock \emph{Annals of Pure and Applied Logic}, 31(2--3):123--144, 1986.

\bibitem{DienerCRM}
H.~Diener.
\newblock Constructive Reverse Mathematics.
\newblock \emph{arXiv:1804.05495}, 2018.

\bibitem{Ishihara90}
H.~Ishihara.
\newblock An omniscience principle, the K\"onig lemma and the Hahn--Banach theorem.
\newblock \emph{Mathematical Logic Quarterly}, 36(3):237--240, 1990.

\bibitem{LeanProver}
The Lean 4 theorem prover.
\newblock \url{https://leanprover.github.io/}

\bibitem{mathlib}
The mathlib4 mathematical library.
\newblock \url{https://github.com/leanprover-community/mathlib4}

\bibitem{PousZdancewic14}
A.~Pous and S.~Zdancewic.
\newblock A linear/producer/consumer model of classical linear logic.
\newblock In \emph{Proceedings of the 29th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS)}, pages 1--10. IEEE, 2014.

\bibitem{BridgesVita06}
D.~S. Bridges and L.~Vîţă.
\newblock \emph{Techniques of Constructive Analysis}.
\newblock Springer, 2006.

\bibitem{Beeson85}
M.~Beeson.
\newblock \emph{Foundations of Constructive Mathematics}.
\newblock Springer, 1985.

\bibitem{TroelstraVanDalen88}
A.~S. Troelstra and D.~van Dalen.
\newblock \emph{Constructivism in Mathematics, Vols.~I--II}.
\newblock North-Holland, 1988.

\bibitem{ConwayFA}
J.~B. Conway.
\newblock \emph{A Course in Functional Analysis}.
\newblock Springer, 2nd ed., 1990.

\bibitem{Megginson98}
R.~E. Megginson.
\newblock \emph{An Introduction to Banach Space Theory}.
\newblock Springer, 1998.

\end{thebibliography}

% ===========================================================
% APPENDICES
% ===========================================================

\appendix

\section{Selected Lean Snippets}

This appendix presents key excerpts from our Lean 4 formalization, demonstrating the witness extraction/analysis architecture and axiom hygiene discussed in the main text. These snippets are illustrative but align with the actual implementation available at \leanRepo.

\subsection{Constructive analysis (witness $\Rightarrow$ \texorpdfstring{$\WLPO$}{WLPO})}

The following shows the purely constructive analysis that derives WLPO from an Ishihara kernel witness without using classical axioms:

\begin{lstlisting}[caption={Constructive analysis of a witness: no classical axioms},label={lst:consumer}]
/-! Constructive analysis: no `open Classical`, no `noncomputable`. -/
structure IshiharaKernel (X : Type _) [NormedAddCommGroup X] [NormedSpace ℝ X] where
  y  : (X →L[ℝ] ℝ) →L[ℝ] ℝ
  f  : X →L[ℝ] ℝ
  g  : (ℕ → Bool) → (X →L[ℝ] ℝ)
  δ  : ℝ
  δpos : 0 < δ
  sep  : ∀ α, |y (f + g α)| = 0 ∨ δ ≤ |y (f + g α)|
  zero_iff_allFalse : ∀ α, (∀ n, α n = false) ↔ y (f + g α) = 0

theorem WLPO_of_kernel
  {X : Type _} [NormedAddCommGroup X] [NormedSpace ℝ X]
  (K : IshiharaKernel X) : WLPO := by
  intro α
  rcases K.sep α with h0 | hpos
  · have : K.y (K.f + K.g α) = 0 := (abs_eq_zero.mp h0)
    exact Or.inl ((K.zero_iff_allFalse α).mpr this)
  · have pos : 0 < |K.y (K.f + K.g α)| := lt_of_lt_of_le K.δpos hpos
    have hne : K.y (K.f + K.g α) ≠ 0 := by
      intro hz; have : |K.y (K.f + K.g α)| = 0 := by simp [hz]
      exact (ne_of_gt pos) this
    have : ¬ (∀ n, α n = false) := by
      intro hall
      have hz : K.y (K.f + K.g α) = 0 := (K.zero_iff_allFalse α).mp hall
      exact hne hz
    exact Or.inr this
\end{lstlisting}

\subsection{Meta-classical witness extraction (Gap $\Rightarrow$ witness)}

The meta-classical witness extraction obtains an Ishihara kernel from a bidual gap. Note the explicit \texttt{noncomputable} and \texttt{open Classical} declarations:

\begin{lstlisting}[caption={Meta-classical witness extraction from a bidual gap},label={lst:producer}]
/-! Meta-classical witness extraction: fenced. Extract a kernel from a bidual gap. -/
noncomputable section
section ClassicalMeta
open Classical

lemma exists_on_unitBall_gt_half_opNorm
  {E} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (T : E →L[ℝ] ℝ) (hT : T ≠ 0) :
  ∃ x : E, ‖x‖ ≤ 1 ∧ (‖T‖ / 2) < ‖T x‖ := by
  by_contra h; push_neg at h
  have bound_all : ∀ x, ‖T x‖ ≤ (‖T‖ / 2) * ‖x‖ := by
    intro x
    by_cases hx : x = 0
    · simp [hx]
    · have hxpos : 0 < ‖x‖ := norm_pos_iff.mpr hx
      let u : E := (‖x‖)⁻¹ • x
      have hu_le : ‖u‖ ≤ 1 := by
        field_simp; rw [norm_smul, Real.norm_of_nonneg (inv_nonneg.mpr (le_of_lt hxpos))]
        simp [ne_of_gt hxpos]
      have hu_ball : ‖T u‖ ≤ ‖T‖ / 2 := h u hu_le
      calc ‖T x‖ = ‖x‖ * ‖T u‖     := by rw [← T.map_smul]; simp [u]
               _ ≤ (‖T‖ / 2) * ‖x‖ := mul_le_mul_of_nonneg_left hu_ball (norm_nonneg x)
  have hle : ‖T‖ ≤ ‖T‖ / 2 := by
    apply ContinuousLinearMap.opNorm_le_bound
    · exact div_nonneg (norm_nonneg T) (by norm_num)
    · intro x; exact bound_all x
  have : ‖T‖ = 0 := by linarith
  exact hT (ContinuousLinearMap.norm_eq_zero.mp this)
\end{lstlisting}

\subsection{Gap $\Rightarrow$ \texorpdfstring{$\WLPO$}{WLPO} (meta-classical bridge)}

This shows the complete meta-classical construction:

\begin{lstlisting}[caption={Meta-classical: from bidual gap to WLPO},label={lst:bridge}]
/-- Meta-classical bridge: from a bidual gap, extract a witness and apply the constructive analysis. -/
theorem WLPO_of_gap (hGap : BidualGapStrong) : WLPO := by
  classical
  rcases hGap with ⟨X, Xng, Xns, Xc, _dualBan, _bidualBan, hNotSurj⟩
  letI : NormedAddCommGroup X := Xng
  letI : NormedSpace ℝ X := Xns
  letI : CompleteSpace X := Xc
  let j := NormedSpace.inclusionInDoubleDual ℝ X
  -- Extract witness y ∉ range(j)
  have : ∃ y : (X →L[ℝ] ℝ) →L[ℝ] ℝ, y ∉ Set.range j := by
    have : ¬ (∀ y, y ∈ Set.range j) := by
      simpa [Function.Surjective, Set.mem_range] using hNotSurj
    push_neg at this
    exact this
  rcases this with ⟨y, hy⟩
  have hy0 : y ≠ 0 := by intro hz; subst hz; exact hy ⟨0, by simp⟩
  -- Find h* with ‖y h*‖ > ‖y‖/2
  obtain ⟨h⋆, -, hbig⟩ := exists_on_unitBall_gt_half_opNorm y hy0
  let δ : ℝ := ‖y h⋆‖ / 2
  have δpos : 0 < δ := by
    have : 0 < ‖y h⋆‖ := lt_of_le_of_lt (div_nonneg (norm_nonneg y) (by norm_num)) hbig
    exact half_pos this
  -- Build kernel components
  let f : X →L[ℝ] ℝ := 0
  let g : (ℕ → Bool) → (X →L[ℝ] ℝ) := fun α => if (∀ n, α n = false) then 0 else h⋆
  have sep : ∀ α, |y (f + g α)| = 0 ∨ δ ≤ |y (f + g α)| := by
    intro α
    by_cases hall : ∀ n, α n = false
    · left;  simp [f, g, hall]
    · right
      have : δ ≤ ‖y h⋆‖ := by
        have hnn : 0 ≤ ‖y h⋆‖ := norm_nonneg _
        simpa [δ] using half_le_self hnn
      -- unfold to |y(f+g α)| and rewrite ‖·‖ = |·|
      simpa [f, g, hall, zero_add, Real.norm_eq_abs]
  have ziff : ∀ α, (∀ n, α n = false) ↔ y (f + g α) = 0 := by
    intro α; constructor
    · intro hall; simp [f, g, hall]
    · intro hz; by_contra hall
      have : y (f + g α) = y h⋆ := by simp [f, g, hall]
      rw [this] at hz; norm_num at hz
      exact absurd hz (ne_of_gt (by exact δpos))
  exact WLPO_of_kernel
    { y := y, f := f, g := g, δ := δ, δpos := δpos, 
      sep := sep, zero_iff_allFalse := ziff }
end ClassicalMeta
\end{lstlisting}

\subsection{WLPO $\to$ Gap (coding-based sketch)}

The reverse direction uses WLPO to construct a gap via sequence coding:

\begin{lstlisting}[caption={WLPO implies gap via coding},label={lst:wlpo-gap}]
/-- Abbreviation: a "code" turning α into a bounded sequence v^α. -/
def codedSeq (α : ℕ → Bool) : ℕ → ℝ :=
  fun n => if (∃ k ≤ n, α k = true) then (1 : ℝ) else 0

lemma codedSeq_in_c0_iff_allFalse (α : ℕ → Bool) :
  (Filter.Tendsto (codedSeq α) Filter.atTop (nhds 0)) ↔ (∀ n, α n = false) := by
  constructor
  · intro htend hall
    -- If α has a true value, sequence stays at 1 eventually
    rcases hall with ⟨m, hm⟩
    have : ∀ n ≥ m, codedSeq α n = 1 := by
      intro n hn; simp [codedSeq]; use m, le_trans (le_of_eq rfl) hn, hm
    -- This contradicts convergence to 0
    have : Filter.Tendsto (codedSeq α) Filter.atTop (nhds 1) := by
      apply tendsto_atTop_of_eventually_const
      use m; intros; apply this; assumption
    exact absurd (tendsto_nhds_unique htend this) (by norm_num)
  · intro hall
    -- If all false, sequence is constantly 0
    have : ∀ n, codedSeq α n = 0 := by
      intro n; simp [codedSeq]
      intro k hk hkt; exact hall k hkt
    simp [this]; exact tendsto_const_nhds

/-- Uses WLPO to separate coded sequences in ℓ∞/c₀ -/
theorem gap_from_WLPO : WLPO → BidualGapStrong := by
  intro hwlpo
  -- Construction uses the coding to build a functional on ℓ∞/c₀
  -- that separates some codedSeq α from c₀
  -- Full proof in Papers.P2_BidualGap.HB.WLPO_to_Gap_pure
  sorry  -- See repository for complete construction
\end{lstlisting}

\subsection{OpNorm core (classical LUB)}

The operator norm construction shows the classical use of suprema:

\begin{lstlisting}[caption={Classical operator norm via supremum},label={lst:opnorm}]
/-- Classical: existence of operator norm via sSup of values on unit ball -/
namespace OpNorm
variable {X : Type*} [NormedAddCommGroup X] [NormedSpace ℝ X]

def valueSet (h : X →L[ℝ] ℝ) : Set ℝ := 
  { r | ∃ x, ‖x‖ ≤ 1 ∧ r = ‖h x‖ }

lemma valueSet_nonempty (h : X →L[ℝ] ℝ) : (valueSet h).Nonempty := 
  ⟨0, 0, by simp⟩
  
lemma valueSet_bddAbove (h : X →L[ℝ] ℝ) : BddAbove (valueSet h) :=
  ⟨‖h‖, by rintro r ⟨x, hx, rfl⟩; exact h.le_opNorm_of_le hx⟩

def HasOpNorm (h : X →L[ℝ] ℝ) : Prop := 
  ∃ N, IsLUB (valueSet h) N

lemma hasOpNorm_classical (h : X →L[ℝ] ℝ) : HasOpNorm h := by
  classical
  use sSup (valueSet h)
  exact isLUB_csSup (valueSet_nonempty h) (valueSet_bddAbove h)
end OpNorm
\end{lstlisting}

\subsection{Stone window (idempotents in the quotient)}

The Stone window construction shows the Boolean algebra structure:

\begin{lstlisting}[caption={Stone window: Boolean algebra of idempotents},label={lst:stone}]
/-- Almost-equality of subsets of ℕ -/
def AlmostEq (A B : Set ℕ) : Prop := (A \ B ∪ B \ A).Finite

/-- Indicator function in ℓ∞ -/
def chi (A : Set ℕ) : ℕ → ℝ := fun n => if n ∈ A then 1 else 0

/-- The quotient ℓ∞/c₀ has a Banach algebra structure -/
instance : Algebra ℝ (ℓ∞ ⧸ c₀) where
  -- Multiplication is pointwise, well-defined modulo c₀
  mul := Quotient.map₂ (fun f g n => f n * g n) (by sorry)
  one := Quotient.mk (fun _ => 1)
  -- Other fields omitted

/-- Boolean algebra of idempotents -/
def Idem (B : Type*) [Mul B] := { e : B // e * e = e }

instance [Mul B] [One B] [Add B] [Sub B] : BooleanAlgebra (Idem B) where
  inf e f := ⟨e.val * f.val, by simp [e.property, f.property]⟩
  sup e f := ⟨e.val + f.val - e.val * f.val, by ring_nf; simp [e.property, f.property]⟩
  compl e := ⟨1 - e.val, by ring_nf; simp [e.property]⟩
  -- Other fields follow from these operations

/-- Stone window isomorphism -/
def StoneWindow : (Set ℕ) ⧸ AlmostEq ≃ Idem (ℓ∞ ⧸ c₀) where
  toFun := Quotient.map (fun A => ⟨Quotient.mk (chi A), by sorry⟩) (by sorry)
  invFun := sorry  -- Inverse via support extraction
  left_inv := by sorry
  right_inv := by sorry
\end{lstlisting}

\subsection{Axiom hygiene verification}

Finally, we can verify the axiom usage as discussed in Section~\ref{sec:axioms}:

\begin{lstlisting}[caption={Axiom audit commands},label={lst:axioms}]
#print axioms WLPO_of_kernel
-- (no axioms)

#print axioms WLPO_of_gap  
-- [propext, Classical.choice, Quot.sound]

#print axioms gap_from_WLPO
-- [propext, Quot.sound]  -- uses WLPO hypothesis, not Classical.choice

#print axioms gap_equiv_wlpo
-- [propext, Classical.choice, Quot.sound]
\end{lstlisting}

The output confirms that the constructive consumer (\texttt{WLPO\_of\_kernel}) uses no classical axioms, while the meta-classical producer (\texttt{WLPO\_of\_gap}) requires classical choice. This validates our CRM methodology claim that the consumer remains purely constructive.

% ===========================================================
\section{Code--Theorem Correspondence for the Direct Dual Construction}
% ===========================================================
\label{app:DirectDualCorrespondence}

This appendix explains how the Lean file
\[
\texttt{Papers/P2\_BidualGap/HB/DirectDual.lean}
\]
formalizes the standard ``direct construction'' used in the reverse direction (WLPO $\Rightarrow$ Gap) and in the classical non--reflexivity argument for $c_0$. Concretely, the file builds a bounded linear functional
\[
G : (c_0^\ast) \to \mathbb R
\qquad\text{via}\qquad
G(f)\;=\;\sum_{n=0}^\infty f(e_n),
\]
and proves that $G(\delta_m)=1$ for all $m$. From this, one derives that $G$ cannot be represented by evaluation at any $x\in c_0$, whence the canonical embedding $J_{c_0}:c_0\to c_0^{\ast\ast}$ is not surjective. The last step is carried out in the file that imports this construction (see remark at the end of this appendix).

\subsection*{A. The target theorem (mathematical form)}

\begin{mdframed}[backgroundcolor=gray!5,linewidth=0pt]
\textbf{Theorem (Direct dual witness for non-surjectivity of $J_{c_0}$).}
Define $G:(c_0^\ast)\to\mathbb{R}$ by $G(f)=\sum_{n} f(e_n)$, where $e_n\in c_0$ is the $n$-th standard basis vector and the series is absolutely convergent. Then for every $m$,
\[
G(\delta_m)=1.
\]
Consequently, if $G=J_{c_0}(x)$ for some $x\in c_0$, then $x_m=G(\delta_m)=1$ for all $m$, contradicting $x\in c_0$. Hence $G\notin \mathrm{im}(J_{c_0})$ and $J_{c_0}$ is not surjective.
\end{mdframed}

This is the classical ``basis/coordinate'' argument: the values of $G$ on the coordinate functionals force the representing vector to be the constant sequence $(1,1,\dots)$, which is not in $c_0$.

\subsection*{B. Modeling choices and core definitions (Lean $\leftrightarrow$ mathematics)}

We model $c_0$ over the discrete space $\mathbb N$ using the standard mathlib type:

\begin{center}
\begin{tabular}{p{0.44\textwidth} p{0.52\textwidth}}
\toprule
\textbf{Lean artifact} & \textbf{Mathematical meaning}\\
\midrule
\verb|abbrev c₀ := ZeroAtInftyContinuousMap ℕ ℝ|
& $c_0=\{x:\mathbb N\to\mathbb R : x_n\to 0\}$ with $\|\cdot\|_\infty$ \\[2pt]
\verb|def e (n : ℕ) : c₀ := …|
& Basis vector $e_n$ ($1$ at $n$, $0$ elsewhere); tends to $0$ outside the singleton $\{n\}$ \\[2pt]
\verb|def δ (n : ℕ) : c₀ →L[ℝ] ℝ := …|
& Coordinate evaluation $\delta_n(x)=x_n$, a bounded linear functional \\[2pt]
\verb|def coeff …|
& Scalar $\mathrm{coeff}(f,n) = f(e_n)/\|f(e_n)\|$ (or $0$ if $f(e_n)=0$) \\[2pt]
\verb|def signVector …|
& Finite ``sign vector'' $\sum_{n\in F}\mathrm{coeff}(f,n)\,e_n \in c_0$ \\[2pt]
\verb|noncomputable def G …|
& $G(f)=\sum_n f(e_n)$ as a continuous linear functional on $c_0^\ast$ \\
\bottomrule
\end{tabular}
\end{center}

The choice \verb|ZeroAtInftyContinuousMap ℕ ℝ| is mathlib's canonical $c_0$; it is isometrically the usual Banach space of real sequences tending to $0$. The proof uses the built--in sup--norm via the map \verb|toBCF| into \verb|BoundedContinuousFunction|.

\subsection*{C. The ``finite signs'' inequality $\sum_{n\in F}\|f(e_n)\|\le \|f\|$}

The core analytic estimate is proved exactly as on paper, using ``sign vectors'':
\[
x_F:=\sum_{n\in F}\mathrm{coeff}(f,n)\,e_n,\qquad \|x_F\|_\infty\le 1,\qquad
f(x_F)=\sum_{n\in F}\|f(e_n)\|.
\]
In Lean this is the lemma:
\begin{itemize}
\item \verb|lemma finite_sum_bound … : ∑ n∈F ‖f (e n)‖ ≤ ‖f‖|,
\end{itemize}
which follows from:
\begin{itemize}
\item \verb|lemma abs_coeff_le_one …| (the sign coefficients have absolute value $\le 1$),
\item \verb|lemma signVector_norm_le_one …| ($\|x_F\|\le 1$),
\item \verb|lemma coeff_mul_eval_abs …| ($\mathrm{coeff}(f,n)\cdot f(e_n)=\|f(e_n)\|$).
\end{itemize}
The proof path is the textbook argument and matches the handwritten derivation line--by--line.

\subsection*{D. Absolute summability and definition of $G$}

From the finite--sum bound, Lean derives the absolute summability of $n\mapsto f(e_n)$:
\begin{itemize}
\item \verb|lemma summable_abs_eval … : Summable (λ n, ‖f (e n)‖)|,
\end{itemize}
and hence summability of $n\mapsto f(e_n)$:
\begin{itemize}
\item \verb|lemma summable_eval … : Summable (λ n, f (e n))|.
\end{itemize}
With this, the series defining $G$ exists and is used to build a continuous linear map:
\begin{itemize}
\item \verb|noncomputable def G : (c₀ →L[ℝ] ℝ) →L[ℝ] ℝ := …|,
\end{itemize}
together with the operator--norm bound
\[
\|G(f)\|\ \le\ \sum_n \|f(e_n)\|\ \le\ \|f\|,
\]
encoded in the Lipschitz proof obligation for \verb|LinearMap.mkContinuous|.

\subsection*{E. Computing $G(\delta_m)=1$}

The key computation is:
\begin{itemize}
\item \verb|lemma G_delta (m : ℕ) : G (δ m) = 1|.
\end{itemize}
Mathematically, $(\delta_m)(e_n)=\mathbf 1_{n=m}$, so the series is the sum of a single $1$. The Lean proof implements exactly this: it identifies the (finite) support of $n\mapsto \delta_m(e_n)$, reduces the $\mathsf{tsum}$ to a finite sum over $\{m\}$, and computes it to be $1$.

\subsection*{F. From $G(\delta_m)=1$ to the non-surjectivity of $J_{c_0}$}

The last step is a purely formal consequence. If $G=J_{c_0}(x)$ for some $x\in c_0$, then
\[
x_m \;=\; J_{c_0}(x)(\delta_m) \;=\; G(\delta_m)\;=\;1 \quad\text{for all }m,
\]
so $x=(1,1,\dots)\notin c_0$. Therefore $G\not\in \mathrm{im}(J_{c_0})$. In the repository this implication is proven in the file that imports \texttt{DirectDual.lean} (see the lemma named along the lines of \texttt{c0\_not\_reflexive\_via\_direct} in \texttt{HB/WLPO\_to\_Gap\_HB.lean}), where the contradiction is discharged using the evaluation identity $J_{c_0}(x)(\delta_m)=x_m$.

\medskip
\noindent\emph{Conclusion.} The sequence of Lean lemmas \texttt{finite\_sum\_bound} $\Rightarrow$ \texttt{summable\_eval} $\Rightarrow$ definition of \texttt{G} $\Rightarrow$ \texttt{G\_delta} formalizes the standard analytical argument and yields the intended witness $G\in c_0^{\ast\ast}\setminus\mathrm{im}(J_{c_0})$ once paired with the short evaluation argument above.

\subsection*{G. Axiom profile and scope}

The file begins with \verb|noncomputable section| and \verb|open Classical| because mathlib's infinite--sum API (\verb|tsum|) and some norm inequalities live in the classical namespace. No additional axioms are introduced by the definitions and lemmas in \texttt{DirectDual.lean}; the construction uses only:
\begin{itemize}
\item the discrete--space model for $c_0$ (\verb|ZeroAtInftyContinuousMap|),
\item basic sup--norm bounds via \verb|BoundedContinuousFunction|,
\item standard series facts (\verb|Summable|, \verb|tsum|),
\item linearity and operator--norm estimates for continuous linear maps.
\end{itemize}

For reproducibility, an axiom audit can be inspected with:
\begin{lstlisting}[language={},numbers=none]
#print axioms Papers.P2.HB.G
#print axioms Papers.P2.HB.G_delta
#print axioms Papers.P2.HB.finite_sum_bound
\end{lstlisting}
which (on our build) report no extra axioms beyond classical logic used by mathlib's series machinery.

\subsection*{H. Minimal crosswalk (code $\leftrightarrow$ paper)}

\begin{center}
\begin{tabular}{@{}p{0.44\textwidth} p{0.52\textwidth}@{}}
\toprule
\textbf{Lean name (this file)} & \textbf{Paper step} \\
\midrule
\verb|abbrev c₀| & $c_0$ as sequences $\to 0$ with $\|\cdot\|_\infty$ \\
\verb|def e (n)| & Basis vector $e_n$ \\
\verb|def δ (n)| & Coordinate functional $\delta_n$ \\
\verb|def coeff|, \verb|def signVector| & Sign--vector device for Hölder--type bound \\
\verb|lemma finite_sum_bound| & $\sum_{n\in F}\|f(e_n)\|\le \|f\|$ \\
\verb|lemma summable_abs_eval|, \verb|summable_eval| & Absolute summability of $n\mapsto f(e_n)$ \\
\verb|noncomputable def G| & $G(f)=\sum_n f(e_n)$, linear and bounded \\
\verb|lemma G_delta| & $G(\delta_m)=1$ \\
\textit{(importing file)} & Conclude $G\notin \mathrm{im}(J_{c_0})$ and so $J_{c_0}$ not surjective \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Where the final contradiction is discharged.}
The contradiction ``$G=J_{c_0}(x)\Rightarrow x=(1,1,\dots)\notin c_0$'' is proved in the file that imports this module (Section~\ref{sec:lean}; see the lemma titled \emph{c_0 is not reflexive via direct construction}). That lemma uses only the two facts exported here: the definition of $G$ and $G(\delta_m)=1$ for all $m$.

\medskip
This establishes that the Lean development in \texttt{DirectDual.lean} exactly represents the handwritten theorem and proof structure, with each mathematical step mirrored by a named Lean definition or lemma and no elided reasoning.

\section{Meta-Classical Witness Extraction and the Producer/Consumer Analogy}
\label{app:MetaWitnessPC}

This appendix explains the proof architecture in standard Constructive Reverse Mathematics (CRM) terms and clarifies the intended role of the producer/consumer metaphor.

\subsection*{A. CRM terminology and proof shape}

In CRM one typically proves implications of the form
\[
\text{(classically)}\qquad \big[\mathsf{BISH} \vdash \mathsf{Thm}\big] \;\Longrightarrow\; \big[\mathsf{BISH} \vdash \mathsf{Prin}\big],
\]
where the \emph{meta-proof} is classical, but the \emph{object-level} target theory is $\mathsf{BISH}$ (intuitionistic). The standard two-stage pattern is:
\begin{enumerate}
\item \textbf{Meta-classical witness extraction.}
Working in classical logic \emph{about} $\mathsf{BISH}$, use the assumed theorem to \emph{produce} a concrete mathematical \emph{witness} (sometimes called a \emph{test object}) whose existence is provable in $\mathsf{BISH}$ and whose properties will be sufficient to derive the target principle.
\item \textbf{Constructive consumption.}
Still inside $\mathsf{BISH}$ (no classical axioms), \emph{consume} only the abstract properties of that witness to derive the logical principle.
\end{enumerate}

Formally, the meta-argument composes two $\mathsf{BISH}$-internal arrows:
\[
\mathsf{BISH} \vdash \big(\mathsf{Thm} \Rightarrow \exists W\,.\,\mathsf{Adequate}(W)\big)
\quad\text{and}\quad
\mathsf{BISH} \vdash \big(\mathsf{Adequate}(W)\Rightarrow \mathsf{Prin}\big).
\]
The first arrow is \emph{proved} meta-classically; the second arrow is proved intuitionistically. (See \cite{Ishihara06,DienerCRM,Ishihara90} for surveys and examples of this pattern.)

\subsection*{B. The witness schema used in this paper}

In our setting the witness is an \emph{Ishihara-style test object} with a sharp \emph{dichotomy} and a \emph{decision} property:
\begin{itemize}
\item A Banach-analytic package $W=(y,f,g,\delta)$ such that for each binary sequence $\alpha$,
\[
\big|y(f + g(\alpha))\big| = 0 \;\;\text{or}\;\; \delta \le \big|y(f + g(\alpha))\big|
\]
\[\text{and}\qquad
\big(\forall n,\,\alpha(n)=0\big)\ \Leftrightarrow\ y(f + g(\alpha))=0.
\]
\item The consumer (\S\ref{sec:lean}, App.~\ref{app:DirectDualCorrespondence}) shows \emph{constructively} that this suffices to decide each WLPO instance $\alpha$.
\end{itemize}

The only logically delicate step is the \emph{extraction} of $W$ from a gap witness in the bidual, where one (i) chooses $y\in X^{**}\setminus J(X)$, (ii) obtains $h^\star\in X^\ast$ with $|y(h^\star)|>\tfrac12|y|$, and (iii) defines $g(\alpha)$ by a global case split on the undecidable predicate $(\forall n, \alpha(n)=0)$. As is standard in CRM, that case split happens in the \emph{meta-classical} part, while the consumer uses only the abstract properties of $W$ and remains intuitionistic. Compare \cite{Ishihara90} for earlier uses of such dichotomy-style witnesses and \cite{DienerCRM} for a general CRM perspective; see also \cite{BrownSimpson86} for related calibrations around Hahn--Banach.

\subsection*{C. How this is organized in Lean (axiom hygiene)}

We make this separation \emph{mechanical}:
\begin{itemize}
\item \textbf{Producer (meta-classical block).}
In the file \texttt{CRM\_MetaClassical/Ishihara.lean}, the witness $W$ is extracted inside a fenced section
\begin{center}
\texttt{noncomputable section}\quad\texttt{section ClassicalMeta}\quad\texttt{open Classical}
\end{center}
which licenses classical reasoning needed for choice and global case splits.
\item \textbf{Consumer (constructive block).}
The theorem \texttt{WLPO\_of\_kernel} (App.\ref{app:DirectDualCorrespondence}, Listing\ref{lst:consumer}) lives \emph{outside} any classical section and uses no classical axioms:
\begin{verbatim}
#print axioms WLPO_of_kernel
-- (no axioms)
\end{verbatim}
\item \textbf{Audit (meta composition).}
The bridge \texttt{WLPO\_of\_gap} composes the two $\mathsf{BISH}$-internal arrows and reports exactly the expected meta-classical footprint:
\begin{verbatim}
#print axioms WLPO_of_gap
-- [propext, Classical.choice, Quot.sound]
\end{verbatim}
\end{itemize}

This confirms the intended CRM architecture: only the extraction uses classical logic; the consumption is purely constructive.

\subsection*{D. The producer/consumer analogy---useful, but just an analogy}

The terms ``producer'' and ``consumer'' are \emph{not} standard CRM jargon; they are metaphors we use to communicate the separation of concerns:
\begin{itemize}
\item The producer is the meta-classical routine that \emph{produces} a witness $W$ from the assumed theorem (here, the bidual gap).
\item The consumer is the constructive routine that \emph{consumes} only the abstract API of $W$ to derive the target principle (here, WLPO).
\end{itemize}

This is an explanatory overlay on the standard witness-extraction pattern in CRM; our paper and code use the precise terms \emph{meta-classical witness extraction} and \emph{constructive consumption} as the primary terminology and ``producer/consumer'' only as a helpful guide.

\paragraph{Relation to linear-logic intuitions (optional).}
There is a useful conceptual parallel to resource sensitivity in linear logic: meta-classical inferences (strong resources) are confined to the extraction phase, while the consumer manipulates only the \emph{type} of $W$ (its API) using constructive rules. We do not rely on any linear-logic machinery; the connection is heuristic and pedagogical.

\subsection*{E. How others use the same mechanism}
\begin{itemize}
\item \textbf{Ishihara (1990):} Uses an Ishihara-style dichotomy witness to calibrate variants of Hahn--Banach and omniscience principles, deriving WLPO-level consequences from analytic hypotheses \cite{Ishihara90}.
\item \textbf{Brown--Simpson (1986):} Calibrate set-existence axioms needed for separable Hahn--Banach, a closely related program in classical reverse mathematics \cite{BrownSimpson86}.
\item \textbf{Diener (CRM overview):} Describes the general two-stage CRM pattern (extract a witness/test object classically; analyze it constructively) across many examples \cite{DienerCRM}.
\end{itemize}

Our development follows this well-trodden schema: the specific \emph{shape} of $W$ is tailored to the bidual-gap setting (the ``Ishihara-style kernel'' used here), but the methodology is the standard CRM pattern of witness extraction and constructive consumption.

\subsection*{F. Minimal formal schema (for readers comparing paper and code)}

\begin{center}
\fbox{\begin{minipage}{0.9\textwidth}
\textbf{Meta-classical step (witness extraction).}
\[
\text{(classically)}\quad
\mathsf{BISH} \vdash \Big(\mathsf{Gap}\ \Rightarrow\ \exists W\,.\,\mathsf{Adequate}(W)\Big)
\]
\textbf{Constructive step (witness consumption).}
\[
\mathsf{BISH} \vdash \Big(\mathsf{Adequate}(W)\ \Rightarrow\ \mathsf{WLPO}\Big)
\]
\textbf{Composition (CRM conclusion).}
\[
\text{(classically)}\quad
\mathsf{BISH} \vdash \big(\mathsf{Gap}\ \Rightarrow\ \mathsf{WLPO}\big).
\]
\end{minipage}}
\end{center}

In our formalization, the first arrow is implemented in \texttt{Ishihara.lean} (producer block) and the second arrow is \texttt{WLPO\_of\_kernel} (consumer block). App.~\ref{app:DirectDualCorrespondence} explains how the direct dual construction (\texttt{DirectDual.lean}) supplies the complementary witness $G$ used for the reverse direction.

\section{WLPO $\Rightarrow$ Bidual Gap via Direct Dual Witness $G$}
\label{app:WLPOtoGap-Direct}

This appendix documents the reverse direction of the equivalence---the direct construction of a non-representable element of $c_0^{**}$---and shows that the Lean code in
\texttt{Papers/P2\_BidualGap/HB/WLPO\_to\_Gap\_HB.lean}
faithfully implements the informal proof.

\subsection*{A. Mathematical statement and proof sketch}

Over $\mathsf{BISH}$ with $\mathsf{WLPO}$ as a hypothesis, we claim that
$J_{c_0}:c_0\to c_0^{**}$ is not surjective.

\textbf{Witness $G$.} For $f\in c_0^\ast$, write $f(e_n)$ for the evaluation of $f$ on the standard basis $e_n\in c_0$ (the function that is 1 at $n$ and 0 elsewhere). Define
\[G(f) \;:=\; \sum_{n=0}^{\infty} f(e_n).\]
Two key facts:
\begin{enumerate}
\item The series $\sum_n f(e_n)$ is absolutely summable (uniform bound on partial sums), hence $G$ is a well-defined bounded linear functional on $c_0^\ast$, i.e. $G\in (c_0^\ast)^\ast=c_0^{**}$.
\item For the coordinate functionals $\delta_m\in c_0^\ast$ (evaluation at $m$), we have $G(\delta_m)=1$ for all $m$.
\end{enumerate}

\textbf{Contradiction.} If $G=J_{c_0}(x)$ for some $x\in c_0$, then
$x_m=J_{c_0}(x)(\delta_m)=G(\delta_m)=1$ for all $m$, so $x$ is the constant sequence 1, which is not in $c_0$ (does not vanish at infinity). Hence $G\notin \mathrm{im}(J_{c_0})$, i.e. $J_{c_0}$ is not surjective.

\subsection*{B. Lean $\leftrightarrow$ Math crosswalk}

The following table matches the informal proof objects to their Lean definitions.

\begin{center}
\begin{tabular}{lll}
\toprule
\textbf{Mathematics} & \textbf{Lean symbol / fact} & \textbf{Where} \\
\midrule
The space $c_0$ on $\mathbb{N}$ & \verb|abbrev c₀ := ZeroAtInftyContinuousMap ℕ ℝ| & DirectDual.lean \\
Basis $e_n\in c_0$ & \verb|def e (n : ℕ) : c₀| & DirectDual.lean \\
Coordinate $\delta_m\in c_0^\ast$ & \verb|def δ (m : ℕ) : c₀ →L[ℝ] ℝ| & DirectDual.lean \\
Witness $G(f)=\sum_n f(e_n)$ & \verb|def G : (c₀ →L[ℝ] ℝ) →L[ℝ] ℝ| & DirectDual.lean \\
Key property $G(\delta_m)=1$ & \verb|lemma G_delta (m) : G (δ m) = 1| & DirectDual.lean \\
Non-surjectivity of $J_{c_0}$ & \verb|lemma c0_not_reflexive_via_direct :| & WLPO\_to\_Gap\_HB.lean \\
& \verb|  ¬ Surjective (inclusionInDoubleDual ℝ c₀)| & \\
Packaging as BidualGapStrong & \verb|lemma wlpo_implies_gap :| & WLPO\_to\_Gap\_HB.lean \\
& \verb|  WLPO → BidualGapStrong.{0}| & \\
Equivalence & \verb|theorem gap_equiv_wlpo :| & WLPO\_to\_Gap\_HB.lean \\
& \verb|  BidualGapStrong.{0} ↔ WLPO| & \\
\bottomrule
\end{tabular}
\end{center}

\textbf{Notes on the core steps}
\begin{itemize}
\item \textbf{Absolute summability:}
DirectDual.lean proves \verb|summable_abs_eval| and \verb|summable_eval| for the sequence $n\mapsto f(e_n)$, then uses \verb|norm_tsum_le_tsum_norm| to bound $\|G\|$. This is the formal counterpart of the textbook estimate $\sum_{n\in F} |f(e_n)| \le \|f\|$ for any finite $F$.
\item \textbf{Computing $G(\delta_m)$:}
\verb|G_delta| reduces the tsum to a finite sum over the support, which is just $\{m\}$, and evaluates $(\delta_m)(e_m)=1$.
\item \textbf{The contradiction:}
In \verb|c0_not_reflexive_via_direct|, assuming surjectivity gives $x$ with $J(x)=G$. Evaluating both sides at $\delta_m$ yields $x_m=1$ for all $m$, contradicting \verb|x.zero_at_infty'| (the vanishing-at-infinity property). This is exactly the informal argument.
\end{itemize}

\subsection*{C. Where $\mathsf{WLPO}$ appears (and where it does not)}

The \emph{contradiction} that $G\notin \mathrm{im}(J_{c_0})$ uses only:
\begin{itemize}
\item the concrete model of $c_0$,
\item the basis $e_n$, coordinates $\delta_m$,
\item the definition and summability of $G$, and
\item the topological fact that elements of $c_0$ tend to 0 at infinity.
\end{itemize}

It does not use any instance of $\mathsf{WLPO}$.
In \verb|wlpo_implies_gap| the hypothesis WLPO is threaded in only to satisfy the packaging requirements of the predicate \verb|BidualGapStrong| (see the two declarations below). The core non-representability of $G$ is independent of WLPO.

\subsection*{D. On the two auxiliary axioms}

The file currently contains
\begin{verbatim}
axiom dual_is_banach_c0_from_WLPO :
  WLPO → DualIsBanach c₀

axiom dual_is_banach_c0_dual_from_WLPO :
  WLPO → DualIsBanach (c₀ →L[ℝ] ℝ)
\end{verbatim}

These are \emph{packaging stubs} for the fields that \verb|BidualGapStrong| asks for (completeness/Banachness of the space and its duals). They are deliberately placed here to avoid entangling the direct $G$-construction with library-level completeness proofs. Two remarks:
\begin{enumerate}
\item \textbf{They do not touch the core argument.}
The contradiction $J_{c_0}(x)=G\Rightarrow x=1$ is proved in \verb|c0_not_reflexive_via_direct| \emph{without} these axioms.
\item \textbf{They are dischargeable.}
In mathlib, one has completeness of $E\to_L F$ once $F$ is complete, and $c_0$ is complete as a closed subspace of bounded continuous functions on a discrete space. Thus these stubs can be replaced by ordinary lemmas/instances (or the \verb|BidualGapStrong| record can be relaxed to require only the standard \verb|CompleteSpace| instances). We keep them localized here solely to decouple the direct dual argument from auxiliary typeclass plumbing.
\end{enumerate}

We highlight this so that readers can see that the formalization mirrors the informal proof structure: the hard analytic content is in DirectDual.lean; the ``gap witness packaging'' around it is orthogonal.

\subsection*{E. Relation to $G=S\circ\Phi_1$ in the text}

Analytically, one often identifies $c_0^\ast \cong \ell^1$ via the coordinate map $\Phi_1(f)=(f(e_n))_n$ and takes $S$ to be the summation functional on $\ell^1$. Our Lean definition of
\[G(f)=\sum_n f(e_n)\]
is exactly the composition $S\circ \Phi_1$ at the level of behavior, but avoids committing to the explicit $c_0^\ast\cong \ell^1$ isomorphism. This keeps the construction lightweight: we use only the unconditional summability proved in DirectDual.lean.

\subsection*{F. CRM positioning (standard terms)}

Unlike the Gap $\Rightarrow$ WLPO direction---where we used a meta-classical \emph{witness extraction} followed by a constructive \emph{consumer}---this WLPO $\Rightarrow$ Gap direction is a direct explicit construction: we build $G\in c_0^{**}$, prove $G\notin J(c_0)$, and then package $c_0$ as the witness space in \verb|BidualGapStrong|. The producer/consumer terminology is still a helpful mental model for the other direction, but here the proof is purely ``producer-style'': we produce the object $G$ outright.

\end{document}