
\documentclass[11pt]{article}

% ------------------------------------------------------------
% Standard LaTeX packages
% ------------------------------------------------------------
\usepackage[margin=1in]{geometry}
\usepackage{lmodern}
\usepackage{amsmath,amssymb,mathtools}
\usepackage{amsthm}
\usepackage[american]{babel}
\usepackage{stmaryrd}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning,cd}
\usepackage{listings}
\usepackage[x11names,table]{xcolor}
\usepackage{graphicx}
\usepackage{array}
\usepackage{mdframed}
\usepackage{url}
% hyperref should typically come last
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}

% Define theorem-like environments
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
% Aliases used in body:
\newtheorem{thm}[theorem]{Theorem}
\newtheorem{lem}[theorem]{Lemma}
\newtheorem{cor}[theorem]{Corollary}
\newtheorem{rem}[theorem]{Remark}
% Alias used in body:
\newenvironment{defi}{\begin{definition}}{\end{definition}}

% ---------- Lean repo link ----------
\newcommand{\leanRepo}{\url{https://github.com/AICardiologist/FoundationRelativity}}
\newcommand{\leanok}{\textsf{\small \textcolor{green!70!black}{\checkmark}}}
\newcommand{\leanpartial}{\textsf{\small \textcolor{orange!80!black}{(partial)}}}

% ---------- Mathematical notation ----------
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\linf}{\ell^\infty}
\newcommand{\cnull}{c_0}
\newcommand{\WLPO}{\mathrm{WLPO}}
\newcommand{\LPO}{\mathrm{LPO}}
\newcommand{\BISH}{\mathrm{BISH}}
\newcommand{\CRM}{\mathrm{CRM}}
\newcommand{\LEM}{\mathrm{LEM}}
\newcommand{\DC}{\mathrm{DC}}
\newcommand{\ZFC}{\mathrm{ZFC}}

% ---------- Code listing style for Lean ----------
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{Lean}{
  keywords={theorem, lemma, def, definition, axiom, structure, class, instance, 
            by, exact, intro, intros, apply, refine, constructor, use, obtain, 
            have, show, from, fun, assume, let, in, if, then, else,
            match, with, end, namespace, section, variable, variables,
            example, begin, sorry, admit, noncomputable, classical,
            import, open, export, private, protected, mutual, meta,
            do, for, while, return, try, catch, finally,
            Type, Prop, Sort, Type*, forall, exists, where, extends},
  sensitive=true,
  morecomment=[l]{--},
  morecomment=[s]{/-}{-/},
  morestring=[b]",
  literate=
    {α}{{$\alpha$}}1 {β}{{$\beta$}}1 {γ}{{$\gamma$}}1
    {δ}{{$\delta$}}1 {ε}{{$\varepsilon$}}1 {ζ}{{$\zeta$}}1
    {η}{{$\eta$}}1 {θ}{{$\theta$}}1 {ι}{{$\iota$}}1
    {κ}{{$\kappa$}}1 {λ}{{$\lambda$}}1 {μ}{{$\mu$}}1
    {ν}{{$\nu$}}1 {ξ}{{$\xi$}}1 {π}{{$\pi$}}1
    {ρ}{{$\rho$}}1 {σ}{{$\sigma$}}1 {τ}{{$\tau$}}1
    {φ}{{$\varphi$}}1 {χ}{{$\chi$}}1 {ψ}{{$\psi$}}1
    {ω}{{$\omega$}}1 {Γ}{{$\Gamma$}}1 {Δ}{{$\Delta$}}1
    {Θ}{{$\Theta$}}1 {Λ}{{$\Lambda$}}1 {Σ}{{$\Sigma$}}1
    {Φ}{{$\Phi$}}1 {Ψ}{{$\Psi$}}1 {Ω}{{$\Omega$}}1
    {→}{{$\rightarrow$}}1 {←}{{$\leftarrow$}}1 {↔}{{$\leftrightarrow$}}1
    {⇒}{{$\Rightarrow$}}1 {⇐}{{$\Leftarrow$}}1 {⇔}{{$\Leftrightarrow$}}1
    {∀}{{$\forall$}}1 {∃}{{$\exists$}}1 {∈}{{$\in$}}1
    {∉}{{$\notin$}}1 {⊆}{{$\subseteq$}}1 {⊂}{{$\subset$}}1
    {∪}{{$\cup$}}1 {∩}{{$\cap$}}1 {≤}{{$\leq$}}1
    {≥}{{$\geq$}}1 {≠}{{$\neq$}}1 {≈}{{$\approx$}}1 {≃}{{$\simeq$}}1
    {≡}{{$\equiv$}}1 {∧}{{$\land$}}1 {∨}{{$\lor$}}1
    {¬}{{$\neg$}}1 {ℕ}{{$\mathbb{N}$}}1 {ℝ}{{$\mathbb{R}$}}1
    {ℂ}{{$\mathbb{C}$}}1 {ℤ}{{$\mathbb{Z}$}}1 {ℓ}{{$\ell$}}1
    {·}{{$\cdot$}}1 {∑}{{$\sum$}}1 {∏}{{$\prod$}}1
    {∅}{{$\emptyset$}}1 {∞}{{$\infty$}}1 {∂}{{$\partial$}}1
    {⟨}{{$\langle$}}1 {⟩}{{$\rangle$}}1 {…}{{$\ldots$}}1
    {₀}{{$_0$}}1 {₁}{{$_1$}}1 {₂}{{$_2$}}1 {⧸}{{$/$}}1 {‖}{{$\|$}}1
    {•}{{$\cdot$}}1 {⁻¹}{{$^{-1}$}}1 {⋆}{{$\star$}}1
}

\lstdefinestyle{leanstyle}{
    language=Lean,
    backgroundcolor=\color{backcolour},    
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    numberstyle=\tiny\color{codegray}
}

\lstset{style=leanstyle}

% ---------- Title and author ----------
% Version: v6 (2026-02-05)
\title{The Bidual Gap and WLPO: A Constructive Calibration of Banach Space Non-Reflexivity}
\author{Paul Chun-Kit Lee\thanks{Lean 4 formalization available at \leanRepo. Code archive available at Zenodo: DOI \texttt{10.5281/zenodo.17107493}.} \\ 
New York University \\ 
\texttt{dr.paul.c.lee@gmail.com}}
\date{2026-02-05}

\begin{document}

\begin{abstract}
We calibrate the logical strength of Banach space non-reflexivity over Bishop-style constructive mathematics (BISH). Writing ``bidual gap'' for the failure of surjectivity of the canonical embedding $J_X\!:X\to X^{**}$, we show---\emph{in a classical metatheory}---that over $\BISH$ the Weak Limited Principle of Omniscience (WLPO) is equivalent to the existence of a bidual gap for some real Banach space (our \texttt{BidualGapStrong}). A classical corollary is the non-surjectivity of $J_{\ell^\infty}$; this corollary is \emph{not} formalized in Lean. The forward implication proceeds by classically extracting an Ishihara kernel (a finite tuple of functionals and a positive threshold) from a gap; the kernel-to-$\WLPO$ step is intuitionistic. Both directions of WLPO $\leftrightarrow$ BidualGapStrong are formalized in Lean~4, and the WLPO$\to$gap direction isolates a small witness-extraction step; we formalize both a WLPO-based lemma (using classical Bool extraction) and an LPO-based variant that provides a constructive witness. We also give finite-dimensional surrogates via Ces\`aro means (paper-level) and include, in Appendix~\ref{app:stone}, a Stone window sketch identifying idempotents of $\ell^\infty/c_0$ with almost-equality classes of subsets of $\mathbb{N}$. This sketch is not used in the main equivalence and is not formalized in Lean. These results sharpen the folklore that the bidual gap is ``non-constructive'' by locating it precisely at $\WLPO$ over $\BISH$.
\end{abstract}

\maketitle

\begin{mdframed}[backgroundcolor=gray!10, linewidth=0pt]
\textbf{IMPORTANT DISCLAIMER}

\textbf{A Case Study: Using Multi-AI Agents to Tackle Formal Mathematics}

This entire Lean 4 formalization project was produced by multi-AI agents working under human direction. All proofs, definitions, and mathematical structures in this repository were AI-generated. This represents a case study in using multi-AI agent systems to tackle complex formal mathematics problems with human guidance on project direction.
\end{mdframed}

\tableofcontents

\section*{AI Assistance and Responsibility}
\addcontentsline{toc}{section}{AI Assistance and Responsibility}

This project used multiple AI systems in a supervised workflow. Initial Lean code and
scaffolding were produced with Claude Code (Opus 4.5). Refactoring and consolidation
were performed with GPT-5.2-Codex (Extra High). Proof-strategy exploration for the
hardest steps was assisted by Gemini 2.5 Pro (Deep Think). All results were reviewed,
edited, and integrated under human oversight; the author retains full responsibility
for correctness.

The author is a practicing cardiologist rather than a professional logician or analyst.
We expect domain experts may find errors or suggest improvements, and we welcome
constructive feedback.

% ===========================================================
\section{Introduction: Foundation Relativity and Logical Calibration}
% ===========================================================

\subsection{The foundation-sensitive bidual gap}

For any Banach space $X$, the canonical embedding $J_X:X\to X^{**}$ maps $x\in X$ to the evaluation functional $J_X(x)(f)=f(x)$ for $f\in X^*$. A central question in functional analysis is whether $J_X$ is surjective; if not, $X$ is non-reflexive, and there exists a ``bidual gap.''

\begin{definition}[Non-reflexivity and bidual gap]
A Banach space $X$ is \textbf{non-reflexive} if the canonical embedding $J_X$ is not surjective. In this case, we say $X$ \textbf{has a bidual gap}.
\end{definition}

For the space $\linf$ of bounded sequences, the answer depends on the foundational setting. In classical mathematics ($\ZFC$), the Hahn--Banach theorem implies that $J_{\linf}$ is not surjective. This $\linf$ corollary is not formalized in the Lean bundle; the formalization focuses on the abstract equivalence and the $c_0$ witness.

However, in Bishop-style constructive mathematics ($\BISH$)---a system based on intuitionistic logic without the Law of Excluded Middle ($\LEM$) or full Choice---one cannot prove that this gap exists. This dependence of provability on foundations exemplifies \emph{foundation relativity}.

\subsection{Motivation: From independence to precise calibration}

This project began by probing whether functional-analytic ``pathologies'' might mirror independence phenomena. While no direct connection to G\"odelian incompleteness emerged, the Lean 4 formalization led to a precise calibration result: the exact logical strength of the bidual gap.

The bidual gap is not independent in the G\"odelian sense, but its provability over $\BISH$ is exactly that of a specific, weak non-constructive principle. This situates the problem within \emph{Constructive Reverse Mathematics} ($\CRM$), whose goal is to determine minimal axioms needed for classical theorems over constructive bases.

\subsection{The Weak Limited Principle of Omniscience (WLPO)}

\begin{defi}[$\WLPO$]
For any binary sequence $\alpha:\N\to\{0,1\}$,
\[
(\forall n,\ \alpha(n)=0)\ \ \vee\ \ \neg(\forall n,\ \alpha(n)=0).
\]
\end{defi}

$\WLPO$ is strictly weaker than $\LEM$ but not provable in $\BISH$. It captures the minimal decision strength needed to determine whether an infinite sequence is identically zero.

\begin{defi}[$\LPO$]
For any binary sequence $\alpha:\N\to\{0,1\}$,
\[
(\forall n,\ \alpha(n)=0)\ \ \vee\ \ \exists n,\ \alpha(n)=1.
\]
\end{defi}

$\LPO$ implies $\WLPO$ and is strictly stronger. In this paper it appears only as an explicit
witness-extraction principle (see the reverse direction and the Constructivity caveat).

\subsection{Main result and contributions}

\begin{thm}[Main Theorem]
Over $\BISH$, the following are equivalent:
\begin{enumerate}
\item $\WLPO$.
\item \textbf{Gap$_{\exists}$:} There exists a real Banach space $X$ such that $J_X:X\to X^{**}$ is not surjective (\texttt{BidualGapStrong}).
\end{enumerate}
Moreover, this equivalence is formalized in Lean~4 (see Section~\ref{sec:lean}).
\end{thm}

\begin{cor}[Classical corollary (not formalized in Lean)]
In $\ZFC$, the embedding $J_{\linf}:\linf\to(\linf)^{**}$ is not surjective. The Lean bundle
includes an abstract Option~B bridge from a nonzero functional on $\linf/\cnull$ to a bidual
gap, but it does not specialize this bridge to $\linf$.
\end{cor}

Our contributions are:
\begin{enumerate}[label=\arabic*.]
\item \textbf{Logical calibration:} an exact equivalence within $\CRM$.
\item \textbf{Formal verification:} a Lean 4 formalization of WLPO $\leftrightarrow$ \texttt{BidualGapStrong} (existence of a gap), plus an abstract Option~B bridge.
\item \textbf{Methodology:} a Prop-level Ishihara kernel and a robust csSup treatment of partial sums.
\item \textbf{Constructive surrogates:} explicit finite-dimensional approximations via Ces\`aro means (paper-level; not formalized in Lean).
\end{enumerate}

% ===========================================================
\section{Main Mathematical Results: The Equivalence Theorem}
% ===========================================================

We explain the equivalence between the bidual gap and $\WLPO$.

\subsection{Forward direction: Gap implies WLPO}

To bridge a bidual-gap witness and a logical decision, we use an ``Ishihara kernel'', adapted from constructive reverse mathematics.

\begin{defi}[Ishihara kernel]
An Ishihara kernel consists of a normed space $X$, an element $y\in X^{**}\setminus J(X)$, a functional $f\in X^*$, a family $g:(\N\to\{0,1\})\to X^*$, and a constant $\delta>0$ such that for all binary sequences $\alpha$:
\begin{enumerate}
\item $|y(f+g(\alpha))|=0$ or $|y(f+g(\alpha))|\ge \delta$ (dichotomy);
\item $(\forall n,\ \alpha(n)=0)\ \Leftrightarrow\ y(f+g(\alpha))=0$ (decision property).
\end{enumerate}
\end{defi}

\begin{lem}[Kernel $\Rightarrow$ $\WLPO$]
If an Ishihara kernel exists, then $\WLPO$ holds.
\end{lem}

\begin{proof}
Given $\alpha$, compute $s=|y(f+g(\alpha))|$. By dichotomy, either $s=0$ or $s\ge \delta>0$. The decision property equates $s=0$ with $(\forall n,\alpha(n)=0)$, deciding the $\WLPO$ instance.
\end{proof}

\begin{thm}[Gap implies $\WLPO$ (meta-classical)]\label{thm:gap-implies-wlpo}
Working in a classical metatheory: if some Banach space $X$ has $J:X\to X^{**}$ not surjective, 
then $\WLPO$ holds over $\BISH$.
\end{thm}

\begin{proof}
Choose $y\in X^{**}\setminus J(X)$ with $y\ne 0$. A half-norm attainment lemma yields $h\in X^*$ with $\|h\|\le 1$ and $|y(h)|>\|y\|/2$. Let $f=0$, $\delta=|y(h)|/2$ (so $\delta>0$ by $0 \leq \|y\|/2 < |y(h)|$), and
\[
g(\alpha)=\begin{cases}
0 & \text{if } \forall n,\alpha(n)=0,\\
h & \text{otherwise}.
\end{cases}
\]
Then the dichotomy and decision properties hold, so the kernel exists.
\end{proof}

\subsection{Foundation-theoretic interlude: Classical logic in reverse mathematics}

Before proceeding to the reverse direction, we must address a subtle but crucial point about the use of classical logic in constructive reverse mathematics.

\begin{rem}[Classical meta-logic vs. object logic]\label{rem:meta-classical}
The definition of $g(\alpha)$ in the proof case-splits on the undecidable proposition
$(\forall n,\alpha(n)=0)$. In $\BISH$, we cannot constructively perform this case split.
However, in reverse mathematics, we work in a \emph{classical meta-logic} to prove
statements \emph{about} $\BISH$.

Concretely, we prove the implication:
\[
  \text{(classically)}\quad
  \big[\text{there exists a Banach space with a bidual gap (a $\BISH$-provable statement)}\big]
  \;\Longrightarrow\;
  \big[\BISH \vdash \WLPO\big].
\]
This is the standard proof strategy in Constructive Reverse Mathematics (CRM), which follows a two-part structure that we frame using a \emph{producer/consumer} analogy \cite{DienerCRM}. First, a \emph{classical producer}, operating in a meta-theory, uses non-constructive reasoning to extract a concrete ``witness''---in our case, an Ishihara kernel---from a classical theorem. Second, a \emph{constructive consumer} analyzes this witness using only the logic of the constructive base theory ($\BISH$) to derive a non-constructive principle like $\WLPO$. This pattern is conceptually analogous to models of linear logic that separate the unlimited production of resources from their disciplined consumption \cite{PousZdancewic14}, thereby clarifying how the non-constructive content of a theorem is isolated before its logical strength is measured.

In the formalization, we fence the meta-classical reasoning (witness extraction and
the case split in $g$) inside a dedicated block, and keep the kernel consumer
(\emph{Ishihara kernel} $\Rightarrow \WLPO$) intuitionistic. No classical axiom
is added to the object theory. This approach follows Ishihara's original pattern for extracting logical principles from functional analysis results \cite{Ishihara90}.

We stress that $\LPO$ is \emph{not} obtained by this meta-classical case split.
Whenever $\LPO$ is used, it is assumed explicitly as an object-level principle
to supply a concrete index (a witness-extraction step). Thus the only meta-classical
reasoning in the paper is the kernel extraction in Gap $\Rightarrow$ $\WLPO$; the
LPO-dependent step belongs entirely to the reverse direction.
\end{rem}

\paragraph{Special note (differences from an earlier draft).}
Two technical changes make the argument robust and CRM-compliant:
\begin{enumerate}
  \item \textbf{Gap parameter.} We set
  \[
    \delta \;:=\; \frac{|y(h^\star)|}{2}\,,
  \]
  where $h^\star\in X^\ast$ satisfies $\|h^\star\|\le 1$ and
  $\tfrac{\|y\|}{2}<|y(h^\star)|$. This yields $\delta>0$ by elementary
  order facts ($0\le \tfrac{\|y\|}{2} < |y(h^\star)|$ implies $0<|y(h^\star)|$,
  hence $0<\delta$). In particular, we do \emph{not} need to derive $\|y\|>0$
  from $y\neq 0$, which would otherwise force norm-positivity lemmas at the bidual
  type and introduce foundational friction in a constructive setting.
  \item \textbf{Fencing classical reasoning.} The only classical steps are:
  picking $y\in X^{**}\!\setminus j(X)$, obtaining $h^\star$, and
  defining $g(\alpha)$ by a global case split. The kernel consumer
  (from the separation statement and the zero-characterization to $\WLPO$)
  is intuitionistic and does not depend on classical principles.
  \item \textbf{Reverse direction aligned with Lean.} Earlier drafts sketched the
  $\WLPO\Rightarrow$ gap direction via a quotient functional on $\ell^\infty/c_0$.
  While correct classically, that presentation obscured a witness-extraction step
  needed to control $\ell^1$ norms constructively. In v6 we instead use the
  explicit $c_0$ witness (matching the Lean development) and make the required
  LPO-style extraction step explicit; see the ``Constructivity caveat'' below.
\end{enumerate}
Both changes are invisible at the level of classical mathematics, but they are
important for constructive reverse mathematics: the consumer no longer relies on
bidual-specific norm facts or undecidable case splits.

\subsection{Reverse direction: WLPO implies gap (via the $c_0$ witness)}

\begin{thm}[$\WLPO$ implies Gap (with explicit witness-extraction)]
Assuming $\WLPO$ and the near-supremum coefficient step for $\ell^1$
(obtained either by classical Bool extraction under WLPO or constructively from $\LPO$),
the canonical embedding $J:c_0\to(c_0)^{**}$ is not surjective.
\end{thm}

\begin{proof}[Proof sketch]
Work with the concrete witness $X=c_0$. Let $(e_n)$ be the standard basis of $c_0$
and $\delta_n\in(c_0)^*$ the coordinate functionals. For $f\in(c_0)^*$, define
\[
  G(f) \;:=\; \sum_{n=0}^\infty f(e_n).
\]
Using the isometric identification $(c_0)^*\cong \ell^1$, the series converges
absolutely and satisfies $|G(f)|\le \|f\|$, so $G\in(c_0)^{**}$. The key analytic
step is a near-supremum coefficient lemma for $\ell^1$; constructively this
requires extracting an index where $|a_n|$ is close to $\sup_n |a_n|$, which is
exactly the LPO-style witness-extraction hypothesis stated above (in Lean, this is
the lemma \texttt{exists\_coeff\_near\_sup\_LPO}).

Finally, $G$ is not in the range of the canonical embedding $J:c_0\to(c_0)^{**}$:
if $G=J(x)$, then $G(\delta_n)=x_n$ for all $n$, but by construction
$G(\delta_n)=1$ for every $n$, forcing $x=(1,1,1,\dots)\notin c_0$.
\end{proof}

\paragraph{Constructivity caveat (WLPO vs.\ LPO).}
The explicit $c_0$ witness relies on a near-supremum coefficient lemma in $\ell^1$.
WLPO alone yields only a disjunction ``all zero'' or ``not all zero'' and does
\emph{not} produce an index witnessing a large coefficient. We therefore isolate
this step in Lean and supply two variants: a WLPO-based lemma
\texttt{exists\_coeff\_near\_sup\_WLPO} that uses classical Bool reasoning to
extract an index, and an LPO-based lemma \texttt{exists\_coeff\_near\_sup\_LPO}
that provides the witness constructively. The LPO lemma yields
\texttt{dual\_is\_banach\_l1\_from\_LPO} and
\texttt{dual\_is\_banach\_c0\_dual\_from\_LPO} in
\texttt{Papers.P2\_BidualGap.HB.WLPO\_DualBanach}. When emphasizing constructive
witness extraction, one should read the WLPO $\Rightarrow$ gap direction as
conditional on this explicit LPO-level step (or a Markov-style substitute).

\subsection{A structural byproduct}

\begin{thm}[Gap structure]\leanpartial
Assuming $\WLPO$, the quotient $\linf/\cnull$ is nontrivial and carries a Boolean algebra of idempotents with rich structure.
\end{thm}

This is a paper-level statement and is not formalized in Lean; it connects naturally with the Stone window sketch in Appendix~\ref{app:stone} (not used in the main equivalence).

% ===========================================================
\section{Constructive Algorithms: Finite Approximations}
% ===========================================================

Finite-dimensional surrogates clarify the constructive boundary: they are computable and illuminating, but their infinite limit would decide $\WLPO$-type predicates.

\subsection{Ces\`aro mean surrogates}

\begin{defi}[Ces\`aro mean]
For $n\ge 1$, define $f_n:\R^n\to\R$ by $f_n(x)=\frac{1}{n}\sum_{i=1}^n x_i$.
\end{defi}

\begin{thm}[Constructive finite Hahn--Banach]\label{thm:finite-hb}\leanpartial
With the sup norm on $\R^n$, the average $f_n(x)=\frac{1}{n}\sum_{i=1}^n x_i$ is the unique linear functional of norm $1$ satisfying $f_n(1,\dots,1)=1$ and $\ker(f_n)=M_n:=\{x\in\R^n:\sum_{i=1}^n x_i=0\}$.
\end{thm}

\begin{proof}
If $\|x\|_\infty\le 1$, then $|f_n(x)|\le \frac{1}{n}\sum_{i=1}^n|x_i|\le 1$, with equality at $x=(1,\dots,1)$, so $\|f_n\|=1$. The kernel claim is immediate from linearity and the definition of $M_n$; uniqueness follows because any linear functional with this kernel and value on $(1,\dots,1)$ must agree with $f_n$ on a direct-sum decomposition $\R^n=M_n\oplus \mathrm{span}\{(1,\dots,1)\}$.
\end{proof}

\noindent\textit{Note.} This finite-dimensional lemma is included as a paper-level surrogate and is not currently formalized in Lean.

\subsection{Computational implementation}

No numerical implementation is included in this bundle; Theorem~\ref{thm:finite-hb} is intended as a paper-level illustration.

\subsection{Convergence and the constructive boundary}

\begin{thm}[Non-constructive limit]
Viewing $(f_n)$ as functionals on $\linf$ via projection, any constructive pointwise limit that separates the encodings described below would decide a $\WLPO$-level predicate, and hence does not exist in $\BISH$.
\end{thm}

\begin{proof}[Proof sketch]
Encode a $\WLPO$ instance $\alpha$ by $v^\alpha\in\linf$; in a simple restricted case (at most one $1$) let $v^\alpha_n=(-1)^{\sum_{k\le n}\alpha_k}$. Then $f_n(v^\alpha)$ converges to different limits depending on whether $\alpha$ is all zeros or has a single $1$. A constructive limit would decide that dichotomy.
\end{proof}

% ===========================================================
\section{Formalization in Lean 4}\label{sec:lean}
% ===========================================================

\subsection{Overview and axiom profile}\label{sec:axioms}

Our Lean 4 formalization contains about 5{,}600 lines of Lean code in this bundle (excluding mathlib).
\begin{itemize}
\item \textbf{Bidirectional proof:} both Gap $\Rightarrow$ $\WLPO$ and $\WLPO$ $\Rightarrow$ Gap.
\item \textbf{Auxiliaries:} near-constructive development of $(\cnull)^*\cong \ell^1$; a Stone window sketch appears in Appendix~\ref{app:stone} (not formalized in Lean).
\item \textbf{Option~B (abstract):} a bridge from a nonzero functional on a quotient to a bidual gap; the $\linf$ specialization is not formalized.
\item \textbf{Axioms:}
\begin{lstlisting}[language=Lean,numbers=none]
#print axioms Papers.P2.HB.gap_equiv_wlpo
-- [propext, Classical.choice, Quot.sound] (typical output)
\end{lstlisting}
Here, \texttt{Quot.sound} underlies quotient constructions used in the development; \texttt{propext} is used extensively at Prop level; and \texttt{Classical.choice} (with \texttt{open Classical}) provides classical case splits in the meta-logic, as discussed in Remark~\ref{rem:meta-classical}.
\end{itemize}

\subsection{CRM methodology and axiom hygiene}\label{sec:crm-hygiene}

Following standard CRM (Constructive Reverse Mathematics) methodology, our formalization 
separates the \emph{classical producer} from the \emph{constructive consumer}:

\begin{itemize}
\item \textbf{Producer (classical):} The construction of the Ishihara kernel from the bidual gap,
  including extraction of $y \in X^{**} \setminus J(X)$, finding $h^\star$ with $\|y\|/2 < \|y(h^\star)\|$,
  and defining $g(\alpha)$ via case-splitting on the undecidable predicate $(\forall n, \alpha(n) = 0)$.
  This is fenced in \texttt{section ClassicalMeta} in \texttt{Ishihara.lean}.

\item \textbf{Consumer (constructive):} The theorem \texttt{WLPO\_of\_kernel} that derives $\WLPO$ 
  from the abstract kernel properties. This is placed \emph{outside} any \texttt{noncomputable} or 
  \texttt{Classical} sections, ensuring pure intuitionistic reasoning.
\end{itemize}

This separation can be mechanically verified in Lean:
\begin{lstlisting}[language=Lean,numbers=none]
#print axioms Papers.P2.Constructive.WLPO_of_kernel
-- (no classical axioms)

#print axioms Papers.P2.Constructive.WLPO_of_gap  
-- [propext, Classical.choice, Quot.sound]
\end{lstlisting}

The result properly demonstrates that in a classical metatheory, 
$\textsf{BISH} \vdash \textsf{BidualGapStrong} \Rightarrow \WLPO$.

\subsection{Reproducibility information}

\begin{mdframed}[backgroundcolor=gray!10]
\textbf{Reproducibility Box}
\begin{itemize}
\item \textbf{Repository}: \leanRepo
\item \textbf{Lean toolchain (root)}: \texttt{leanprover/lean4:v4.23.0-rc2}
\item \textbf{Lake}: \texttt{Lake 5.0.0-src+ad1a017 (Lean 4.23.0-rc2)}
\item \textbf{mathlib4 commit}: \texttt{24dd4cacbe11d2535f2537c4a64ab25f72842cee}
\item \textbf{Project tag}: \texttt{p2-crm-v0.2}; \textbf{current commit}: \texttt{483dd449fd699ec91296a617295d27f9db161d0f}
\item \textbf{Build (Paper 2 full)}: \texttt{lake build Papers.P2\_BidualGap.P2\_Full}
\item \textbf{Build (Paper 2 minimal)}: \texttt{lake build Papers.P2\_BidualGap.P2\_Minimal}
\item \textbf{Full repo build}: \texttt{lake build} (long; compiles mathlib)
\item \textbf{Code Archive DOI}: \texttt{10.5281/zenodo.17107493}
\item \textbf{Status}: \texttt{P2\_Full} and \texttt{P2\_Minimal} build. WIP files contain sorries and are excluded. The WLPO$\to$gap direction isolates a witness-extraction step; we provide an LPO-based variant for that step (see Constructivity caveat).
\end{itemize}
\end{mdframed}

\subsection{Key technical solutions}

\paragraph{Prop-level kernel technique.}
We implement the Ishihara kernel entirely at Prop level.

\begin{lstlisting}[caption={Ishihara kernel (illustrative Lean snippet)}]
structure IshiharaKernel (X : Type _) [NormedAddCommGroup X] [NormedSpace ℝ X] where
  y     : (X →L[ℝ] ℝ) →L[ℝ] ℝ
  f     : X →L[ℝ] ℝ
  g     : (ℕ → Bool) → (X →L[ℝ] ℝ)
  δ     : ℝ
  δpos  : 0 < δ
  sep   : ∀ α : ℕ → Bool, |y (f + g α)| = 0 ∨ δ ≤ |y (f + g α)|
  zero_iff_allFalse :
    ∀ α : ℕ → Bool, (∀ n, α n = false) ↔ y (f + g α) = 0

theorem WLPO_of_kernel
  {X : Type _} [NormedAddCommGroup X] [NormedSpace ℝ X]
  (K : IshiharaKernel X) : WLPO := by
  intro α
  have h := K.sep α
  rcases h with h0 | hpos
  · have yz0 : K.y (K.f + K.g α) = 0 := (abs_eq_zero.mp h0)
    exact Or.inl ((K.zero_iff_allFalse α).mpr yz0)
  · have hne : K.y (K.f + K.g α) ≠ 0 := by
      intro yz0; have : |K.y (K.f + K.g α)| = 0 := by simp [yz0]
      exact (ne_of_gt (lt_of_lt_of_le K.δpos hpos)) this
    exact Or.inr (by
      intro hall
      exact hne ((K.zero_iff_allFalse α).mp hall))
\end{lstlisting}

\paragraph{Robust csSup for partial sums.}
We avoid fragile complete-lattice instance resolution by working directly with conditional suprema:
\begin{lstlisting}[caption={tsum equals csSup of finite partial sums}]
private lemma tsum_eq_csSup_sum_of_nonneg
  {ι : Type*} (u : ι → ℝ) (h0 : ∀ i, 0 ≤ u i) (hs : Summable u) :
  (∑' i, u i) = sSup (Set.range (fun s : Finset ι => ∑ i ∈ s, u i)) := by
  have nonempty : (Set.range _).Nonempty := ⟨0, ∅, by simp⟩
  have bdd : BddAbove (Set.range _) := by
    use ∑' i, u i
    rintro x ⟨s, rfl⟩
    exact sum_le_tsum s (fun i _ => h0 i) hs
  apply le_antisymm
  · apply tsum_le_of_sum_le hs; intro s; exact le_csSup bdd ⟨s, rfl⟩
  · apply csSup_le nonempty; rintro x ⟨s, rfl⟩
    exact sum_le_tsum s (fun i _ => h0 i) hs
\end{lstlisting}

\paragraph{HasWLPO architecture.}
A lightweight typeclass separates WLPO-dependent arguments from constructive cores.

\begin{lstlisting}[caption={WLPO typeclass sketch}]
class HasWLPO : Prop :=
  (wlpo : ∀ (α : ℕ → Bool), (∀ n, α n = false) ∨ ¬(∀ n, α n = false))

namespace HasWLPO
theorem em_all_false [HasWLPO] (α : ℕ → Bool) :
    (∀ n, α n = false) ∨ ¬ (∀ n, α n = false) :=
  (inferInstance : HasWLPO).wlpo α
end HasWLPO

noncomputable instance instHasWLPO_of_Classical : HasWLPO := by
  classical
  refine ⟨?_⟩
  intro α
  simpa using Classical.em (∀ n, α n = false)
\end{lstlisting}

\subsection{The bidirectional theorem (Lean)}

\begin{lstlisting}[caption={WLPO $\leftrightarrow$ Gap (top-level equivalence)}]
open Papers.P2.HB

theorem gap_equiv_wlpo : BidualGapStrong.{0} ↔ WLPO := by
  constructor
  · exact gap_implies_wlpo
  · exact wlpo_implies_gap
\end{lstlisting}

% ===========================================================
\section{Significance and Conclusion}
% ===========================================================

\subsection{Precise logical calibration}

The result places a familiar analytic phenomenon exactly at $\WLPO$, demonstrating how constructive reverse mathematics can sharpen vague ``non-constructive'' labels into precise equivalences.

\subsection{Foundation relativity}

\begin{center}
\small % Make text smaller instead of resizing
\begin{tabular}{lll}
\toprule
Foundation & Statement about the gap ($\exists y\notin \mathrm{im}(J)$) & Comment \\
\midrule
$\ZFC$ & \emph{Holds} & Hahn--Banach yields witnesses \\
$\BISH$ & \emph{Equivalent to $\WLPO$} & (Main Theorem) \\
$\BISH+\DC$ & \emph{Equivalent to $\WLPO$} & $\DC$ does not imply $\WLPO$ \\
$\BISH+\WLPO$ & \emph{Holds} & by equivalence \\
$\BISH+\neg\WLPO$ & \emph{Not provable} & fails in models of $\BISH+\neg\WLPO$ \\
\bottomrule
\end{tabular}
\end{center}

\subsection{The role of formalization}

The Lean development clarified axiom usage, suggested robust approaches to conditional suprema, and yielded reusable patterns (Ishihara kernel, HasWLPO) for future formalized reverse mathematics.

\subsection{Conclusion}

We establish and formalize that the existence of a bidual gap has exactly the logical strength of $\WLPO$ over $\BISH$. Finite constructive surrogates illuminate the obstruction at the infinite limit. The approach integrates constructive analysis, reverse mathematics, and mechanized verification.

\section*{Acknowledgments}

I thank colleagues and the Lean community for discussions around constructive analysis and formal verification.

\smallskip
\noindent\textbf{AI assistance disclosure.} During development we used large language models as programming assistants: Claude Code (Opus 4.5) for initial Lean scaffolding, GPT-5.2-Codex (Extra High) for refactoring and consolidation, and Google Gemini 2.5 Pro (Deep Think) for difficult proof-strategy exploration. All suggested code and text were reviewed, edited, and verified by the author; the final mathematical claims are machine-checked by Lean~4 against mathlib. No model is credited as an author, and the author bears full responsibility for all content and any errors.

\bibliographystyle{alphaurl}
\begin{thebibliography}{10}

\bibitem{Bishop67}
E.~Bishop.
\newblock \emph{Foundations of Constructive Analysis}.
\newblock McGraw-Hill, 1967.

\bibitem{Ishihara06}
H.~Ishihara.
\newblock Reverse mathematics in Bishop's constructive mathematics.
\newblock \emph{Philosophia Scientiae}, Cahier Sp\'ecial 6:43--59, 2006.

\bibitem{AlbiacKalton16}
F.~Albiac and N.~J. Kalton.
\newblock \emph{Topics in Banach Space Theory}.
\newblock Springer, 2nd edition, 2016.

\bibitem{Bridges87}
D.~S. Bridges and F.~Richman.
\newblock \emph{Varieties of Constructive Mathematics}.
\newblock Cambridge University Press, 1987.

\bibitem{BrownSimpson86}
D.~K. Brown and S.~G. Simpson.
\newblock Which set existence axioms are needed to prove the separable Hahn--Banach theorem?
\newblock \emph{Annals of Pure and Applied Logic}, 31(2--3):123--144, 1986.

\bibitem{DienerCRM}
H.~Diener.
\newblock Constructive Reverse Mathematics.
\newblock \emph{arXiv:1804.05495}, 2018.

\bibitem{Ishihara90}
H.~Ishihara.
\newblock An omniscience principle, the K\"onig lemma and the Hahn--Banach theorem.
\newblock \emph{Mathematical Logic Quarterly}, 36(3):237--240, 1990.

\bibitem{LeanProver}
The Lean 4 theorem prover.
\newblock \url{https://leanprover.github.io/}

\bibitem{mathlib}
The mathlib4 mathematical library.
\newblock \url{https://github.com/leanprover-community/mathlib4}

\bibitem{PousZdancewic14}
A.~Pous and S.~Zdancewic.
\newblock A linear/producer/consumer model of classical linear logic.
\newblock In \emph{Proceedings of the 29th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS)}, pages 1--10. IEEE, 2014.

\end{thebibliography}

% ===========================================================
% APPENDICES
% ===========================================================

\appendix

\section{Stone Window (Sketch)}\label{app:stone}

This appendix records a sketch of the Stone window correspondence. It is independent
of the main WLPO $\leftrightarrow$ gap equivalence and is not formalized in Lean.

\subsection{Almost-equality and idempotents}

\begin{defi}[Almost equality]
For $A,B\subseteq\N$, write $A\sim B$ if the symmetric difference $A\triangle B$ is finite.
\end{defi}

\begin{defi}
Write $\mathrm{Idem}(B)$ for the set of idempotents of a (commutative) Banach algebra $B$ under the induced Boolean operations $e\wedge f:=ef$, $e\vee f:=e+f-ef$, and $\neg e:=1-e$.
\end{defi}

\begin{thm}[Stone window]\label{thm:stone}\leanpartial
Equip $\ell^\infty/c_0$ with the quotient Banach algebra structure induced by pointwise operations. The map
$\Phi:\mathcal{P}(\N)/{\sim}\to \mathrm{Idem}(\linf/\cnull)$,
$[A]\mapsto [\chi_A]$, is a Boolean algebra isomorphism.
\end{thm}

\begin{proof}[Proof sketch]
(1) $[\chi_A]=[\chi_B]$ iff $\chi_A-\chi_B\in \cnull$, i.e.\ $A\sim B$.  
(2) Boolean operations are respected.  
(3) Every idempotent is equivalent (mod $\cnull$) to an indicator via thresholding at $1/2$.
\end{proof}

\begin{cor}[Finite distributive lattices]\leanpartial
Every finite distributive lattice embeds into $\mathrm{Idem}(\linf/\cnull)$.
\end{cor}

\subsection{Lean sketch}

\textit{(Sketch; not formalized in the Lean development.)}
\begin{lstlisting}[caption={Stone window: Boolean algebra of idempotents (sketch)},label={lst:stone}]
/-- Almost-equality of subsets of ℕ -/
def AlmostEq (A B : Set ℕ) : Prop := (A \ B ∪ B \ A).Finite

/-- Indicator function in ℓ∞ -/
def chi (A : Set ℕ) : ℕ → ℝ := fun n => if n ∈ A then 1 else 0

/-- The quotient ℓ∞/c₀ has a Banach algebra structure -/
instance : Algebra ℝ (ℓ∞ ⧸ c₀) where
  -- Multiplication is pointwise, well-defined modulo c₀
  mul := Quotient.map₂ (fun f g n => f n * g n) (by sorry)
  one := Quotient.mk (fun _ => 1)
  -- Other fields omitted

/-- Boolean algebra of idempotents -/
def Idem (B : Type*) [Mul B] := { e : B // e * e = e }

instance [Mul B] [One B] [Add B] [Sub B] : BooleanAlgebra (Idem B) where
  inf e f := ⟨e.val * f.val, by simp [e.property, f.property]⟩
  sup e f := ⟨e.val + f.val - e.val * f.val, by ring_nf; simp [e.property, f.property]⟩
  compl e := ⟨1 - e.val, by ring_nf; simp [e.property]⟩
  -- Other fields follow from these operations

/-- Stone window isomorphism -/
def StoneWindow : (Set ℕ) ⧸ AlmostEq ≃ Idem (ℓ∞ ⧸ c₀) where
  toFun := Quotient.map (fun A => ⟨Quotient.mk (chi A), by sorry⟩) (by sorry)
  invFun := sorry  -- Inverse via support extraction
  left_inv := by sorry
  right_inv := by sorry
\end{lstlisting}

\section{Selected Lean Snippets}

This appendix presents key excerpts from our Lean 4 formalization, demonstrating the producer/consumer architecture and axiom hygiene discussed in the main text. These snippets are illustrative but align with the actual implementation available at \leanRepo.

\subsection{Constructive consumer (Ishihara kernel $\to$ WLPO)}

The following shows the purely constructive consumer that derives WLPO from an Ishihara kernel without using classical axioms:

\begin{lstlisting}[caption={Constructive consumer: no classical axioms},label={lst:consumer}]
/-! Constructive consumer (Ishihara.lean). -/
structure IshiharaKernel (X : Type _) [NormedAddCommGroup X] [NormedSpace ℝ X] where
  y     : (X →L[ℝ] ℝ) →L[ℝ] ℝ
  f     : X →L[ℝ] ℝ
  g     : (ℕ → Bool) → (X →L[ℝ] ℝ)
  δ     : ℝ
  δpos  : 0 < δ
  sep   : ∀ α : ℕ → Bool, |y (f + g α)| = 0 ∨ δ ≤ |y (f + g α)|
  zero_iff_allFalse :
    ∀ α : ℕ → Bool, (∀ n, α n = false) ↔ y (f + g α) = 0

theorem WLPO_of_kernel
  {X : Type _} [NormedAddCommGroup X] [NormedSpace ℝ X]
  (K : IshiharaKernel X) : WLPO := by
  intro α
  have h := K.sep α
  rcases h with h0 | hpos
  · have yz0 : K.y (K.f + K.g α) = 0 := (abs_eq_zero.mp h0)
    exact Or.inl ((K.zero_iff_allFalse α).mpr yz0)
  · have pos : 0 < |K.y (K.f + K.g α)| := lt_of_lt_of_le K.δpos hpos
    have hne : K.y (K.f + K.g α) ≠ 0 := by
      intro yz0; have : |K.y (K.f + K.g α)| = 0 := by simp [yz0]
      exact (ne_of_gt pos) this
    have : ¬ (∀ n, α n = false) := by
      intro hall
      have yz0 : K.y (K.f + K.g α) = 0 := (K.zero_iff_allFalse α).mp hall
      exact hne yz0
    exact Or.inr this
\end{lstlisting}

\subsection{Classical producer (Gap $\to$ kernel)}

The classical producer extracts an Ishihara kernel from a bidual gap. Note the explicit \texttt{noncomputable} and \texttt{open Classical} declarations:

\begin{lstlisting}[caption={Classical producer: extracting kernel from gap},label={lst:producer}]
/-! Classical producer: fenced in `section ClassicalMeta`. -/
noncomputable section
section ClassicalMeta
open Classical

lemma exists_on_unitBall_gt_half_opNorm
  {E} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (T : E →L[ℝ] ℝ) (hT : T ≠ 0) :
  ∃ x : E, ‖x‖ ≤ 1 ∧ (‖T‖ / 2) < ‖T x‖ := by
  classical
  by_contra h
  push_neg at h
  -- ... proof uses scaling on the unit ball and opNorm_le_bound
  -- ... then derives ‖T‖ = 0, contradiction

end ClassicalMeta
\end{lstlisting}

\subsection{Gap $\to$ WLPO (full bridge)}

This shows the complete meta-classical construction:

\begin{lstlisting}[caption={Meta-classical: from bidual gap to WLPO},label={lst:bridge}]
/-- Meta-classical: from a bidual gap, build a kernel and consume it. -/
theorem WLPO_of_gap (hGap : BidualGapStrong) : WLPO := by
  classical
  rcases hGap with ⟨X, Xng, Xns, Xc, _dualBan, _bidualBan, hNotSurj⟩
  letI : NormedAddCommGroup X := Xng
  letI : NormedSpace ℝ X := Xns
  letI : CompleteSpace X := Xc
  let j := NormedSpace.inclusionInDoubleDual ℝ X
  have : ∃ y : (X →L[ℝ] ℝ) →L[ℝ] ℝ, y ∉ Set.range j := by
    have : ¬ (∀ y, y ∈ Set.range j) := by
      simpa [Function.Surjective, Set.mem_range] using hNotSurj
    push_neg at this
    exact this
  rcases this with ⟨y, hy⟩
  have hy0 : y ≠ 0 := by intro h0; subst h0; exact hy ⟨0, by simp⟩
  obtain ⟨hstar, hstar_le1, hstar_big⟩ :
      ∃ h : (X →L[ℝ] ℝ), ‖h‖ ≤ 1 ∧ (‖y‖ / 2) < ‖y h‖ := by
    simpa using
      (exists_on_unitBall_gt_half_opNorm (E := (X →L[ℝ] ℝ)) y hy0)
  let δ : ℝ := ‖y hstar‖ / 2
  have δpos : 0 < δ := by
    -- uses 0 ≤ ‖y‖/2 < ‖y hstar‖
    have : 0 < ‖y hstar‖ := by
      have h0 : 0 ≤ ‖y‖ / 2 := div_nonneg (norm_nonneg y) (by norm_num)
      exact lt_of_le_of_lt h0 hstar_big
    simpa [δ] using half_pos this
  let f : X →L[ℝ] ℝ := 0
  let g : (ℕ → Bool) → (X →L[ℝ] ℝ) := fun α =>
    if (∀ n, α n = false) then 0 else hstar
  have sep : ∀ α, |y (f + g α)| = 0 ∨ δ ≤ |y (f + g α)| := by
    intro α; by_cases hall : ∀ n, α n = false
    · left; simp [f, g, hall]
    · right
      have : δ ≤ ‖y hstar‖ := by
        have hnn : 0 ≤ ‖y hstar‖ := norm_nonneg _
        simpa [δ] using half_le_self hnn
      simpa [f, g, hall, zero_add] using this
  have zero_iff_allFalse : ∀ α, (∀ n, α n = false) ↔ y (f + g α) = 0 := by
    intro α; constructor
    · intro hall; simp [f, g, hall]
    · intro h0; by_contra hnot
      have yh_eq : y (f + g α) = y hstar := by simpa [f, g, hnot, zero_add]
      have yh0 : y hstar = 0 := by simpa [yh_eq] using h0
      have pos : 0 < ‖y hstar‖ := by
        have h0' : 0 ≤ ‖y‖ / 2 := div_nonneg (norm_nonneg y) (by norm_num)
        exact lt_of_le_of_lt h0' hstar_big
      have zero : ‖y hstar‖ = 0 := by simpa [yh0]
      have : (0 : ℝ) < 0 := by simpa [zero] using pos
      exact lt_irrefl _ this
  exact WLPO_of_kernel (X := X)
    { y := y, f := f, g := g, δ := δ, δpos := δpos
      sep := sep, zero_iff_allFalse := zero_iff_allFalse }
\end{lstlisting}

\subsection{WLPO $\to$ Gap (Lean formalization)}

The Lean development proves the reverse direction by a direct construction using the
explicit bidual witness for $c_0$ and WLPO-based dual-Banach lemmas:

\begin{lstlisting}[caption={WLPO implies gap (Lean)},label={lst:wlpo-gap}]
local notation "c₀" => C₀(ℕ, ℝ)

/-- WLPO ⇒ BidualGapStrong via direct construction. -/
lemma wlpo_implies_gap : WLPO → BidualGapStrong.{0} := by
  intro hWLPO
  have gap_c0 : ¬Function.Surjective (inclusionInDoubleDual ℝ c₀) :=
    c0_not_reflexive_via_direct
  use c₀
  exact ⟨inferInstance, inferInstance, inferInstance,
         dual_is_banach_c0_from_WLPO_struct hWLPO,
         dual_is_banach_c0_dual_from_WLPO hWLPO,
         gap_c0⟩
\end{lstlisting}

This appears in \texttt{Papers.P2\_BidualGap.HB.WLPO\_to\_Gap\_HB}.

\subsection{OpNorm core (classical LUB)}

The operator norm construction shows the classical use of suprema:

\begin{lstlisting}[caption={Classical operator norm via supremum},label={lst:opnorm}]
/-- Classical: existence of operator norm via sSup of values on unit ball. -/
namespace OpNorm
variable {X : Type*} [NormedAddCommGroup X] [NormedSpace ℝ X]

def valueSet (h : X →L[ℝ] ℝ) : Set ℝ :=
  { r | ∃ x, ‖x‖ ≤ 1 ∧ r = ‖h x‖ }

lemma valueSet_nonempty (h : X →L[ℝ] ℝ) : (valueSet h).Nonempty := by
  refine ⟨0, ?_⟩
  exact ⟨0, by simp, by simp⟩

lemma valueSet_bddAbove (h : X →L[ℝ] ℝ) : BddAbove (valueSet h) := by
  refine ⟨‖h‖, ?_⟩
  intro r hr
  rcases hr with ⟨x, hx, rfl⟩
  calc
    ‖h x‖ ≤ ‖h‖ * ‖x‖ := h.le_opNorm x
    _     ≤ ‖h‖ * 1   := mul_le_mul_of_nonneg_left hx (norm_nonneg _)
    _     = ‖h‖       := by simp

def HasOpNorm (h : X →L[ℝ] ℝ) : Prop :=
  ∃ N : ℝ, IsLUB (valueSet h) N

lemma hasOpNorm_CLF (h : X →L[ℝ] ℝ) : HasOpNorm h := by
  classical
  use sSup (valueSet h)
  exact isLUB_csSup (valueSet_nonempty h) (valueSet_bddAbove h)

lemma hasOpNorm_zero : HasOpNorm (0 : X →L[ℝ] ℝ) :=
  hasOpNorm_CLF (0 : X →L[ℝ] ℝ)
end OpNorm
\end{lstlisting}

\subsection{Axiom hygiene verification}

Finally, we can verify the axiom usage as discussed in Section~\ref{sec:axioms}:

\begin{lstlisting}[caption={Axiom audit commands},label={lst:axioms}]
#print axioms Papers.P2.Constructive.WLPO_of_kernel
-- (no classical axioms)

#print axioms Papers.P2.Constructive.WLPO_of_gap
-- [propext, Classical.choice, Quot.sound]

#print axioms Papers.P2.HB.wlpo_implies_gap
-- [propext, Quot.sound]  -- uses WLPO hypothesis, not Classical.choice

#print axioms Papers.P2.HB.gap_equiv_wlpo
-- [propext, Classical.choice, Quot.sound]
\end{lstlisting}

The output confirms that the constructive consumer (\texttt{WLPO\_of\_kernel}) uses no classical axioms, while the meta-classical producer (\texttt{WLPO\_of\_gap}) requires classical choice. This validates our CRM methodology claim that the consumer remains purely constructive.

\end{document}
