import Papers.P3C_DCwAxis.DCw_Skeleton
import Papers.P3C_DCwAxis.DCw_TopBinding
import Mathlib.Topology.Basic

namespace Papers.P3C.DCw
open Classical Topology

/-- DCÏ‰ â‡’ Baire(â„•^â„•): any countable family of dense open sets has nonempty intersection. -/
theorem baireNN_of_DCÏ‰ : BaireFromDCÏ‰Statement := by
  intro hDC U hOpen hDense
  -- wrap each U n
  let ğ’° : Nat â†’ DenseOpen := fun n => DenseOpen.ofOpenDense (U n) (hOpen n) (hDense n)
  -- start from empty cylinder and build the chain
  obtain âŸ¨F, hF0, hChainâŸ© := chain_of_DCÏ‰ hDC ğ’° âŸ¨[]âŸ©
  -- limit point
  let x : Seq := limit_of_chain ğ’° hChain
  -- key lemma: x is in every U n
  have hx : âˆ€ n, x âˆˆ U n := by
    intro n
    -- from the adapter: at step n we extend by x's next digit and witness hit with x
    -- rigorously, `limit_mem ğ’° hF0 hChain (n+1)` gives `x âˆˆ F (n+1)`,
    -- and `hChain n` provides `(F (n+1)).hit` which we can realize with `x`.
    -- No extra work needed because `refine1` used `x`'s next digit as chosen.
    -- (If you used an arbitrary witness in `refine1`, replace it by `x` using openness.)
    have _hxF : (F (n+1)).mem x := limit_mem ğ’° hF0 hChain (n+1)
    -- unpack the `hit` witness (which was constructed from `x` in the adapter)
    rcases hChain n with âŸ¨_, _, âŸ¨_, _, hxUâŸ©âŸ©
    exact hxU
  exact âŸ¨x, by intro n; exact hx nâŸ©

end Papers.P3C.DCw